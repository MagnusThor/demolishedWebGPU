/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./example/Example.js":
/*!****************************!*\
  !*** ./example/Example.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Geometry_1 = __webpack_require__(/*! ../src/Geometry */ \"./src/Geometry.js\");\nconst Material_1 = __webpack_require__(/*! ../src/Material */ \"./src/Material.js\");\nconst Renderer_1 = __webpack_require__(/*! ../src/Renderer */ \"./src/Renderer.js\");\nconst ITexture_1 = __webpack_require__(/*! ../src/ITexture */ \"./src/ITexture.js\");\nconst Rectangle_1 = __webpack_require__(/*! ./meshes/Rectangle */ \"./example/meshes/Rectangle.js\");\nconst Scene_1 = __webpack_require__(/*! ../src/Scene */ \"./src/Scene.js\");\nconst Mesh_1 = __webpack_require__(/*! ../src/Mesh */ \"./src/Mesh.js\");\nconst yy_fps_1 = __webpack_require__(/*! yy-fps */ \"./node_modules/yy-fps/dist/fps.es.js\");\nconst prismBreakShader_1 = __webpack_require__(/*! ./shaders/wglsl/prismBreakShader */ \"./example/shaders/wglsl/prismBreakShader.js\");\ndocument.addEventListener(\"DOMContentLoaded\", () => __awaiter(void 0, void 0, void 0, function* () {\n    const canvas = document.querySelector('canvas');\n    const fps = new yy_fps_1.FPS();\n    const renderer = new Renderer_1.Renderer(canvas);\n    const device = yield renderer.getDevice();\n    const scene = new Scene_1.Scene(\"myScene\", device, canvas);\n    const material = new Material_1.Material(device, prismBreakShader_1.prismBreakShader);\n    const geometry = new Geometry_1.Geometry(device, Rectangle_1.rectGeometry);\n    const textures = [\n        {\n            key: \"iChannel0\",\n            source: \"assets/channel0.jpg\", // ms \n            type: ITexture_1.TextureType.IMAGE,\n        },\n        {\n            key: \"iChannel1\",\n            source: \"assets/channel1.jpg\",\n            type: ITexture_1.TextureType.IMAGE\n        },\n    ];\n    const mesh = new Mesh_1.Mesh(device, geometry, material, [textures[0], textures[1]]);\n    yield scene.addAssets(textures);\n    scene.addMesh(\"myMesh\", mesh);\n    yield renderer.addScene(scene);\n    renderer.start(0, 200, (frameNo) => {\n        fps.frame();\n    });\n}));\n\n\n//# sourceURL=webpack://demolishedwebgpu/./example/Example.js?");

/***/ }),

/***/ "./example/meshes/Rectangle.js":
/*!*************************************!*\
  !*** ./example/meshes/Rectangle.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.rectGeometry = void 0;\nconst Geometry_1 = __webpack_require__(/*! ../../src/Geometry */ \"./src/Geometry.js\");\nexports.rectGeometry = {\n    verticesType: Geometry_1.VERTEXType.xyz,\n    vertices: new Float32Array([\n        -1, 1, 0,\n        -1, -1, 0,\n        1, -1, 0,\n        1, 1, 0,\n        -1, 1, 0,\n        1, -1, 0,\n    ]),\n    indicies: new Uint16Array([0, 1, 2, 3, 4, 5]),\n};\n\n\n//# sourceURL=webpack://demolishedwebgpu/./example/meshes/Rectangle.js?");

/***/ }),

/***/ "./example/shaders/wglsl/prismBreakShader.js":
/*!***************************************************!*\
  !*** ./example/shaders/wglsl/prismBreakShader.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.prismBreakShader = void 0;\nconst Material_1 = __webpack_require__(/*! ../../../src/Material */ \"./src/Material.js\");\nexports.prismBreakShader = {\n    vertex: Material_1.defaultWglslVertex,\n    fragment: /* glsl */ `\r\n    \r\n    struct Uniforms {\r\n      resolution: vec3<f32>,\r\n      time: f32\r\n    };\r\n\r\n    @group(0) @binding(0) var<uniform> uniforms: Uniforms;\r\n\r\n\t// @group(0) @binding(1) var linearSampler: sampler;\r\n  \t// @group(0) @binding(2) var iChannel0: texture_2d<f32>; \r\n\t// @group(0) @binding(3) var iChannel1: texture_2d<f32>; \r\n\t// @group(0) @binding(4) var iChannel2: texture_2d<f32>; \r\n\t// @group(0) @binding(5) var iChannel3: texture_2d<f32>; \r\n\r\n    // Soundtrack Done with 4klang by Gopher / Alcatraz\r\n    // Effets is a webgpu port of the \"Prism Break\" 4k intro by Alcatraz  \r\n     \r\n\r\nconst kl: f32 = 0.;\r\n\r\nvar<private> ef: i32 = 1;\r\nvar<private> ot: vec4<f32>;\r\nvar<private>glFragCoord: vec2<f32>;\r\n\r\nfn rotXaxis(p: vec3<f32>, rad: f32) -> vec3<f32> {\r\n\r\n    var pvar:vec3<f32>;\r\n\r\n\tvar z2: f32 = cos(rad) * p.z - sin(rad) * p.y;\r\n\tlet y2: f32 = sin(rad) * p.z + cos(rad) * p.y;\r\n\t\r\n    pvar.z = z2;\r\n\tpvar.y = y2;\r\n\treturn pvar;\r\n} \r\n\r\nfn rotYaxis(p: vec3<f32>, rad: f32) -> vec3<f32> {\r\n    var pvar:vec3<f32>;\r\n\r\n\tlet x2: f32 = cos(rad) * p.x - sin(rad) * p.z;\r\n\tlet z2: f32 = sin(rad) * p.x + cos(rad) * p.z;\r\n\t\r\n    pvar.x = x2;\r\n\tpvar.z = z2;\r\n\treturn p;\r\n} \r\n\r\nfn rand1(co: vec2<f32>) -> f32 {\r\n\treturn fract(sin(dot(co.xy, vec2<f32>(12.98, 78.23))) * 43758.54);\r\n} \r\n\r\nfn sdBox(p: vec3<f32>, b: vec3<f32>) -> f32 {\r\n\tvar d: vec3<f32> = abs(p) - b;\r\n    var dd:vec3<f32> = max(d, vec3<f32>(0));\r\n\r\n\treturn min(max(d.x, max(d.y, d.z)), 0.) + length(dd);\r\n} \r\n\r\nfn Boxes(pos: vec3<f32>) -> f32 {\r\n\tlet rok: vec3<f32> = vec3<f32>(0.35);\r\n\tvar m: f32;\r\n\tm = length(max(abs(rotYaxis(rotXaxis(pos + vec3<f32>(0., -0.3, 0.), uniforms.time * 0.3), uniforms.time * 0.15)) - rok, vec3<f32>(0))) - 0.03;\r\n\tm = min(m, length(max(abs(rotYaxis(rotXaxis(pos + vec3<f32>(0., -0.3, 1.2), uniforms.time * 0.21), uniforms.time * 0.24)) - rok, vec3<f32>(0))) - 0.03);\r\n\tm = min(m, length(max(abs(rotYaxis(rotXaxis(pos + vec3<f32>(0., -0.3, -1.2), uniforms.time * 0.2), uniforms.time * 0.3)) - rok, vec3<f32>(0))) - 0.03);\r\n\tm = min(m, length(max(abs(rotYaxis(rotXaxis(pos + vec3<f32>(1.2, -0.3, 0.), uniforms.time * 0.17), uniforms.time * 0.26)) - rok, vec3<f32>(0))) - 0.03);\r\n\tm = min(m, length(max(abs(rotYaxis(rotXaxis(pos + vec3<f32>(-1.2, -0.3, 0.), uniforms.time * 0.32), uniforms.time * 0.2)) - rok, vec3<f32>(0))) - 0.03);\r\n\treturn m;\r\n} \r\n\r\nfn Singlebox(pos: vec3<f32>) -> f32 {\r\n\treturn length(max(abs(rotXaxis(pos + vec3<f32>(0., -0.5, 0.), uniforms.time * 0.47)) - vec3<f32>(0.55 - 0.025 * (kl + 0.4) * sin(pos.z * pos.x * pos.y * 35.)), vec3<f32>(0))) - 0.025;\r\n} \r\n\r\nfn sdPlane(p: vec3<f32>) -> f32 {\r\n\treturn p.y + 0.005 * sin(p.x * 10.) + 0.005 * sin(p.z * 12.) + 0.4;\r\n} \r\n\r\nfn menger(pos: vec3<f32>) -> f32 {\r\n\tvar d: f32 = sdBox(pos, vec3<f32>(1.));\r\n\tvar s: f32 = 1.63 + 0.07 * sin(0.53 * uniforms.time) - 0.3 * pos.y;\r\n\r\n\tfor (var m: i32 = 0; m < 2; m = m + 1) {\r\n\t\tlet a: vec3<f32> = ((pos * s) % (2.)) - 1.;\r\n\t\ts = s * (3.);\r\n\t\tvar r: vec3<f32> = abs(1. - 3. * abs(a)) - 0.025;\r\n\t\tlet da: f32 = max(r.x, r.y);\r\n\t\tlet db: f32 = max(r.y, r.z);\r\n\t\tlet dc: f32 = max(r.z, r.x);\r\n\t\tlet c: f32 = (min(da, min(db, dc)) - 1.) / s;\r\n\t\td = max(d, c);\r\n\t}\r\n\r\n\treturn d;\r\n} \r\n\r\nfn map(p: vec3<f32>) -> f32 {\r\n\tvar d: f32;\r\n\tvar m: f32;\r\n\tot = vec4<f32>(length(p) - 0.8 * p.z, length(p) - 0.8 * p.y, length(p) - 0.8 * p.x, 0.) * 0.8;\r\n\td = sdPlane(p);\r\n\tif (ef == 0) { m = Boxes(p); }\r\n\tif (ef == 1 || ef == 3) { m = menger(rotYaxis(p, 0.12 * uniforms.time)); }\r\n\tif (ef == 2) { m = Singlebox(p + 0.1 * kl * rand1(glFragCoord.xy + uniforms.time)); }\r\n\tif (ef == 4) { m = min(menger(rotYaxis(p, 0.1 * uniforms.time)), sdBox(rotYaxis(rotXaxis(p + vec3<f32>(0., 0.2, 0.), uniforms.time), 0.2 * uniforms.time), vec3<f32>(0.1, 0.1, 0.04) - 0.002 * sin(p.x * p.y * 440. + uniforms.time)) - 0.01); }\r\n\treturn min(m, d);\r\n} \r\n\r\nfn softshadow(ro: vec3<f32>, rd: vec3<f32>) -> f32 {\r\n\tvar sh: f32 = 1.;\r\n\tvar t: f32 = 0.02;\r\n\tvar h: f32 = 0.;\r\n\r\n\tfor (var i: i32 = 0; i < 23; i = i + 1) {\r\n\t\tif (t > 20.) {\t\tcontinue;\r\n }\r\n\t\th = map(ro + rd * t) + 0.003 * rand1(glFragCoord.xy + uniforms.time);\r\n\t\tsh = min(sh, 4. * h / t);\r\n\t\tt = t + (h);\r\n\t}\r\n\r\n\treturn sh;\r\n} \r\n\r\nfn calcNormal(p: vec3<f32>) -> vec3<f32> {\r\n\tvar e: vec3<f32> = vec3<f32>(0.0001, 0., 0.);\r\n\tif (ef == 1) { e = vec3<f32>(0.01, 0., 0.); }\r\n\treturn normalize(vec3<f32>(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy), map(p + e.yyx) - map(p - e.yyx)));\r\n} \r\n\r\nfn cycle(c: vec3<f32>, s: f32) -> vec3<f32> {\r\n\tlet Cycles: f32 = 10.;\r\n\treturn vec3<f32>(0.5) + 0.5 * vec3<f32>(cos(s * Cycles + c.x), cos(s * Cycles + c.y), cos(s * Cycles + c.z));\r\n} \r\n\r\nfn getColor(o: f32) -> vec3<f32> {\r\n    let Z: vec4<f32> = vec4<f32>(0.3, 0.5, 0.6, 0.2);\r\n    let Y: vec4<f32> = vec4<f32>(0.1, 0.5, 1.0, -0.5);\r\n    let X: vec4<f32> = vec4<f32>(0.7, 0.8, 1.0, 0.3);\r\n    var orbitColor: vec3<f32> = cycle(X.xyz, ot.x) * X.w * ot.x + cycle(Y.xyz, ot.y) * Y.w * ot.y + cycle(Z.xyz, ot.z) * Z.w * ot.z;\r\n\r\n    orbitColor.x = clamp(3.0 * orbitColor.x, 0.0, 4.0);\r\n    orbitColor.y = clamp(3.0 * orbitColor.y, 0.0, 4.0);\r\n    orbitColor.z = clamp(3.0 * orbitColor.z, 0.0, 4.0);\r\n\r\n    return orbitColor;\r\n}\r\n\r\n\r\nfn castRay(ro: vec3<f32>, rd: vec3<f32>, maxt: f32) -> f32 {\r\n\tvar precis: f32 = 0.001;\r\n\tvar h: f32 = precis * 2.;\r\n\tvar t: f32 = 0.;\r\n\r\n\tfor (var i: i32 = 0; i < 130; i = i + 1) {\r\n\t\tif (abs(h) < precis || t > maxt) {\t\t\r\n            break;\r\n    }\r\n\t\th = map(ro + rd * t);\r\n\t\tt = t + (h);\r\n\t}\r\n\r\n\treturn t;\r\n} \r\n\r\nfn castRay2(ro: vec3<f32>, rd: vec3<f32>) -> f32 {\r\n\tlet precis: f32 = 0.2;\r\n\tvar h: f32 = 0.;\r\n\tvar t: f32 = 0.01;\r\n\r\n\tfor (var i: i32 = 0; i < 90; i = i + 1) {\r\n\t\tif (abs(h) > precis) {\t\t\r\n            break;\r\n    }\r\n\t\th = map(ro + rd * t);\r\n\t\tt = t - (h);\r\n\t}\r\n\r\n\treturn t;\r\n} \r\n\r\n\r\n\r\n\tfn mainImage(invocation_id: vec4<f32>) -> vec4<f32> {\r\n\r\n        glFragCoord = invocation_id.xy;\r\n\r\n        let R: vec2<f32> = uniforms.resolution.xy;\r\n        let y_inverted_location = vec2<i32>(i32(invocation_id.x), i32(R.y) - i32(invocation_id.y));\r\n        let location = vec2<i32>(i32(invocation_id.x), i32(invocation_id.y));\r\n        \r\n        var fragColor: vec4<f32>;\r\n        var fragCoord = vec2<f32>(f32(location.x), f32(location.y) );\r\n    \r\n        if (uniforms.time > 32.) { \r\n            ef = 0; \r\n        }\r\n        \r\n        let blend: f32 = min(2. * abs(sin(0.1 * uniforms.time * 3.1415 / 3.2)), 1.);\r\n        \r\n        var uv: vec2<f32>;\r\n        \r\n        var p: vec2<f32> = vec2<f32>(0.);\r\n\r\n        if (ef == 1 || ef == 3) {\r\n\r\n            uv.x = 1. + (((glFragCoord.x - sin(uniforms.time) * glFragCoord.y - uniforms.resolution.x / 2.) % (uniforms.resolution.x / 4. * (-1.5 * blend + 0.501) + uniforms.resolution.x / 4.)) - 1. * glFragCoord.x) / uniforms.resolution.x;\r\n            uv.y = 1. + (((glFragCoord.y + sin(uniforms.time) * glFragCoord.x - uniforms.resolution.y / 2.) % (uniforms.resolution.y / 4. * (-1.5 * blend + 0.501) + uniforms.resolution.y / 4.)) - 1. * glFragCoord.y) / uniforms.resolution.y;\r\n        \r\n        }\r\n        if (ef == 0 || ef == 2) {\r\n\r\n            uv.x = 1. + (((glFragCoord.x - uniforms.resolution.x / 2.) % (uniforms.resolution.x / 4. * (-1.5 * blend + 0.501) + uniforms.resolution.x / 4.)) - 1. * glFragCoord.x) / uniforms.resolution.x;\r\n            uv.y = 1. - glFragCoord.y / uniforms.resolution.y;\r\n        }\r\n        p = (1. - uv) * 2. - 1.;\r\n        if (ef == 4) {\r\n            \r\n            var uvxy = uv.xy;\r\n\r\n            uvxy = glFragCoord.xy / uniforms.resolution.xy;\r\n            uv.x = uvxy.x;\r\n            uv.y = uvxy.y;\r\n\r\n            p = uv * 2. - 1.;\r\n\r\n        }\r\n        \r\n        p.x = p.x * (uniforms.resolution.x / uniforms.resolution.y);\r\n\r\n        let theta: f32 = sin(uniforms.time * 0.1) * 6.28;\r\n        let x: f32 = 3. * cos(theta);\r\n        let z: f32 = 3. * sin(theta);\r\n\r\n        var ro: vec3<f32>;\r\n        \r\n        if (ef == 0 || ef == 2) {  ro = vec3<f32>(x * 2., 2. + 2. * sin((uniforms.time + 37.) * 0.15), z * 1.4); }\r\n        if (ef == 1) { ro = vec3<f32>(x * 0.2 + 1., 4., 0.6 * z - 3.); }\r\n        if (ef == 4) { ro = vec3<f32>(0., 0.3 + 0.1 * uniforms.time, 0.001); }\r\n        if (ef == 3) { ro = vec3<f32>(0., 36. - 0.24 * uniforms.time, 0.001); }\r\n        \r\n        let cw: vec3<f32> = normalize(vec3<f32>(0., 0.25, 0.) - ro);\r\n        \r\n        let cp: vec3<f32> = vec3<f32>(0., 1., 0.);\r\n        let cu: vec3<f32> = normalize(cross(cw, cp));\r\n        let cv: vec3<f32> = normalize(cross(cu, cw));\r\n        let rd: vec3<f32> = normalize(p.x * cu + p.y * cv + 7.5 * cw);\r\n\r\n        var col: vec3<f32> = vec3<f32>(0.);\r\n        var t: f32 = castRay(ro, rd, 12.);\r\n\r\n        if (t >= 12.) { t = 12.; }\r\n        let pos: vec3<f32> = ro + rd * t;\r\n        let nor: vec3<f32> = calcNormal(pos);\r\n        var ligvec: vec3<f32> = vec3<f32>(-0.5, 0.2, 0.5);\r\n        if (ef == 4 || ef == 2 || ef == 1) { ligvec = vec3<f32>(0.5 * sin(uniforms.time * 0.2), 0.2, -0.5 * cos(uniforms.time * 0.3)); }\r\n        let lig: vec3<f32> = normalize(ligvec);\r\n        let dif: f32 = clamp(dot(lig, nor), 0., 1.);\r\n        let spec: f32 = pow(clamp(dot(reflect(rd, nor), lig), 0., 1.), 16.);\r\n        var color: vec3<f32> = (3.5 - 0.35 * t) * getColor(1.);\r\n        col = 0.3 * dif + 0.5 * color + spec;\r\n        let sh: f32 = softshadow(pos, lig);\r\n        col = col * (clamp(sh, 0., 1.));\r\n        let ro2r: vec3<f32> = pos - rd / t;\r\n        let rd2r: vec3<f32> = reflect(rd, nor);\r\n        let t2r: f32 = castRay(ro2r, rd2r, 7.);\r\n        var pos2r: vec3<f32> = vec3<f32>(0.);\r\n        pos2r = ro2r + rd2r * t2r;\r\n        let nor2r: vec3<f32> = calcNormal(pos2r);\r\n        let dif2r: f32 = clamp(dot(lig, nor2r), 0., 1.);\r\n        let spec2r: f32 = pow(clamp(dot(reflect(rd2r, nor2r), lig), 0., 1.), 16.);\r\n        col = col + (0.1 * (dif2r * color + spec2r));\r\n        var rd2: vec3<f32> = refract(rd, nor, 0.78);\r\n        var t2: f32 = castRay2(pos, rd2);\r\n        var pos2: vec3<f32> = pos + rd2 * t2;\r\n        var nor2: vec3<f32> = calcNormal(pos2);\r\n        var dif2: f32 = clamp(dot(lig, nor2), 0., 1.);\r\n        col.r = col.r + (0.3 * dif2);\r\n        rd2 = refract(rd, nor, 0.82);\r\n        t2 = castRay2(pos, rd2);\r\n        pos2 = pos + rd2 * t2;\r\n        nor2 = calcNormal(pos2);\r\n        dif2 = clamp(dot(lig, nor2), 0., 1.);\r\n        col.b = col.b + (0.3 * dif2);\r\n        rd2 = refract(rd, nor, 0.8);\r\n        t2 = castRay2(pos, rd2);\r\n        pos2 = pos + rd2 * t2;\r\n        nor2 = calcNormal(pos2);\r\n        dif2 = clamp(dot(lig, nor2), 0., 1.);\r\n        let spec2: f32 = pow(clamp(dot(reflect(rd2, nor2), lig), 0., 1.), 16.);\r\n        col.g = col.g + (0.3 * dif2);\r\n        col = col + (0.6 * spec2);\r\n        let ro3: vec3<f32> = pos2 + rd;\r\n        let rd3: vec3<f32> = rd2 + 0.002 * rand1(glFragCoord.xy);\r\n        var t3: f32 = castRay(ro3, rd3, 10.);\r\n        if (t3 >= 10.) { t3 = 10.; }\r\n        let pos3: vec3<f32> = ro3 + rd3 * t3;\r\n        let nor3: vec3<f32> = calcNormal(pos3);\r\n        let dif3: f32 = clamp(dot(lig, -nor3), 0., 1.);\r\n\r\n        color = clamp(vec3<f32>(1.0) + (vec3<f32>(1.0) - vec3<f32>(0.2) * t3) * getColor(1.0), vec3<f32>(0.0), vec3<f32>(8.0));\r\n\r\n        col = col + (0.1 * dif3 * color);\r\n        col = col + (0.04 * (1. - dif3) * color);\r\n        col = mix(col, vec3<f32>(0.4, 0.5, 0.6), exp(-(2. - 0.18 * t)));\r\n        let uv2: vec2<f32> = glFragCoord.xy / uniforms.resolution.xy;\r\n        col = col - (0.04 * rand1(uv2.xy * uniforms.time));\r\n        col = col * (0.9 + 0.1 * sin(2. * uv2.y * uniforms.resolution.y));\r\n        col = col - (1. - dot(uv, 1. - uv) * 2.4);\r\n    \r\n\r\n\r\n\r\n        fragColor = vec4<f32>(col,1.0);\r\n\r\n        return fragColor;\r\n\r\n\t}\r\n\r\n\r\n\tstruct VertexOutput {\t\t\r\n        @builtin(position) pos: vec4<f32>,\r\n        @location(0) uv: vec2<f32>,\r\n    };  \r\n\r\n\r\n\r\n@fragment\r\nfn main_fragment(in: VertexOutput) -> @location(0) vec4<f32> {      \r\n\r\n\treturn mainImage(in.pos);\r\n\t\r\n}\r\n\r\n`\n};\n\n\n//# sourceURL=webpack://demolishedwebgpu/./example/shaders/wglsl/prismBreakShader.js?");

/***/ }),

/***/ "./src/Geometry.js":
/*!*************************!*\
  !*** ./src/Geometry.js ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Geometry = exports.DefaultIndicies = exports.VERTEXType = void 0;\nvar VERTEXType;\n(function (VERTEXType) {\n    VERTEXType[VERTEXType[\"xyz\"] = 3] = \"xyz\";\n    VERTEXType[VERTEXType[\"xyzw\"] = 4] = \"xyzw\";\n    VERTEXType[VERTEXType[\"xyzrgba\"] = 7] = \"xyzrgba\";\n    VERTEXType[VERTEXType[\"xyzwrgba\"] = 8] = \"xyzwrgba\";\n})(VERTEXType || (exports.VERTEXType = VERTEXType = {}));\nexports.DefaultIndicies = new Uint16Array([0, 1, 2, 3, 4, 5]);\n// let createBuffer = (arr: Float32Array | Uint16Array, usage: number) => {\n//     let desc = {\n//         size: (arr.byteLength + 3) & ~3,\n//         usage,\n//         mappedAtCreation: true\n//     };\n//     let buffer = this.device.createBuffer(desc);\n//     const writeArray =\n//         arr instanceof Uint16Array\n//             ? new Uint16Array(buffer.getMappedRange())\n//             : new Float32Array(buffer.getMappedRange());\n//     writeArray.set(arr);\n//     buffer.unmap();\n//     return buffer;\n//};\nclass Geometry {\n    createBuffer(arr, usage, vertexSize) {\n        let desc = {\n            size: (arr.byteLength + vertexSize) & ~vertexSize,\n            usage,\n            mappedAtCreation: true\n        };\n        let buffer = this.device.createBuffer(desc);\n        const writeArray = arr instanceof Uint16Array\n            ? new Uint16Array(buffer.getMappedRange())\n            : new Float32Array(buffer.getMappedRange());\n        writeArray.set(arr);\n        buffer.unmap();\n        return buffer;\n    }\n    constructor(device, model) {\n        this.device = device;\n        this.model = model;\n        this.vertexBuffer = this.createBuffer(model.vertices, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST, model.verticesType);\n        this.indexBuffer = this.createBuffer(model.indicies, GPUBufferUsage.INDEX, 3);\n        this.numOfVerticles = model.vertices.length / model.verticesType;\n    }\n    vertexBufferLayout(shaderLocation) {\n        const vertexBufferLayout = {\n            attributes: [{\n                    shaderLocation: shaderLocation,\n                    offset: 0,\n                    format: 'float32x2'\n                }],\n            arrayStride: 4 * this.model.verticesType,\n            stepMode: 'vertex'\n        };\n        return vertexBufferLayout;\n    }\n}\nexports.Geometry = Geometry;\n\n\n//# sourceURL=webpack://demolishedwebgpu/./src/Geometry.js?");

/***/ }),

/***/ "./src/ITexture.js":
/*!*************************!*\
  !*** ./src/ITexture.js ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TextureType = void 0;\nvar TextureType;\n(function (TextureType) {\n    TextureType[TextureType[\"IMAGE\"] = 0] = \"IMAGE\";\n    TextureType[TextureType[\"VIDEO\"] = 1] = \"VIDEO\";\n    TextureType[TextureType[\"CANVAS\"] = 2] = \"CANVAS\";\n    TextureType[TextureType[\"MEDIASTREAM\"] = 3] = \"MEDIASTREAM\";\n})(TextureType || (exports.TextureType = TextureType = {}));\n\n\n//# sourceURL=webpack://demolishedwebgpu/./src/ITexture.js?");

/***/ }),

/***/ "./src/Material.js":
/*!*************************!*\
  !*** ./src/Material.js ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Material = exports.defaultWglslVertex = void 0;\nexports.defaultWglslVertex = `  \r\n\r\nstruct VertexInput {\r\n  @location(0) pos: vec2<f32>,\r\n  @builtin(vertex_index) index : u32\r\n};  \r\n\r\nstruct VertexOutput {\r\n  @builtin(position) pos: vec4<f32>,\r\n  @location(0) uv: vec2<f32>,\r\n  @location(1) fragCoord: vec2<f32>\r\n};  \r\n\r\n\r\n@vertex\r\nfn main_vertex(input:VertexInput) -> VertexOutput {\r\n\r\n    var output: VertexOutput;\r\n\r\n    var pos: vec2<f32> = input.pos * 2.0 - 1.0;\r\n    output.pos = vec4<f32>(pos, 0.0, 1.0);\r\n    output.uv = pos;\r\n    output.fragCoord = vec2<f32>((pos.x + 1.0) / 2.0, (1.0 - pos.y) / 2.0); \r\n\r\n    return output;\r\n}`;\nclass Material {\n    constructor(device, shader) {\n        this.device = device;\n        this.shader = shader;\n        this.vertexShaderModule = this.device.createShaderModule({\n            code: shader.vertex\n        });\n        this.fragmentShaderModule = this.device.createShaderModule({\n            code: shader.fragment\n        });\n    }\n    static createMaterialShader(vertex, fragment, vertexEntryPoint, fragmentEntryPoint) {\n        const material = {\n            fragment: fragment,\n            fragmentEntryPoint: fragmentEntryPoint,\n            vertex: vertex,\n            vertexEntryPoint: vertexEntryPoint\n        };\n        return material;\n    }\n}\nexports.Material = Material;\n\n\n//# sourceURL=webpack://demolishedwebgpu/./src/Material.js?");

/***/ }),

/***/ "./src/Mesh.js":
/*!*********************!*\
  !*** ./src/Mesh.js ***!
  \*********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Mesh = void 0;\nclass Mesh {\n    constructor(device, geometry, material, textures) {\n        this.device = device;\n        this.geometry = geometry;\n        this.material = material;\n        this.isEnables = true;\n        const layoutEntrys = [\n            {\n                binding: 0,\n                visibility: window.GPUShaderStage.FRAGMENT,\n                buffer: {\n                    type: \"uniform\"\n                }\n            }\n        ];\n        if (textures.length > 0) {\n            layoutEntrys.push({\n                binding: 1,\n                visibility: window.GPUShaderStage.FRAGMENT,\n                sampler: {\n                    type: \"filtering\"\n                }\n            });\n            for (let i = 0; i < textures.length; i++) { //  1-n texture bindings\n                if (textures[i].type === 0) {\n                    layoutEntrys.push({\n                        binding: 2 + i,\n                        visibility: window.GPUShaderStage.FRAGMENT,\n                        texture: {\n                            sampleType: \"float\"\n                        }\n                    });\n                }\n                else { //  external texture ( video )\n                    layoutEntrys.push({\n                        binding: 2 + i,\n                        visibility: window.GPUShaderStage.FRAGMENT,\n                        externalTexture: {}\n                    });\n                }\n            }\n        }\n        this.bindGroupLayout = this.device.createBindGroupLayout({\n            entries: layoutEntrys\n        });\n        this.pipelineLayout = this.device.createPipelineLayout({\n            bindGroupLayouts: [this.bindGroupLayout],\n        });\n    }\n    pipelineDescriptor() {\n        const pipelineDescriptor = {\n            vertex: {\n                module: this.material.vertexShaderModule,\n                entryPoint: this.material.shader.vertexEntryPoint || 'main_vertex',\n                buffers: [this.geometry.vertexBufferLayout(0)]\n            },\n            fragment: {\n                module: this.material.fragmentShaderModule,\n                entryPoint: this.material.shader.fragmentEntryPoint || 'main_fragment',\n                targets: [{\n                        format: 'bgra8unorm'\n                    }]\n            },\n            // depthStencil: {\n            //     format: 'depth32float',\n            //     depthWriteEnabled: true,\n            //     depthCompare: 'less'\n            // },\n            primitive: {\n                topology: 'triangle-list',\n            },\n            layout: this.pipelineLayout\n        };\n        return pipelineDescriptor;\n    }\n}\nexports.Mesh = Mesh;\n\n\n//# sourceURL=webpack://demolishedwebgpu/./src/Mesh.js?");

/***/ }),

/***/ "./src/Renderer.js":
/*!*************************!*\
  !*** ./src/Renderer.js ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Renderer = void 0;\nclass Renderer {\n    constructor(canvas, mainVertex, mainFragment) {\n        this.canvas = canvas;\n        if (mainVertex && mainFragment) {\n            this.mainPipelineLayout = this.device.createPipelineLayout({\n                bindGroupLayouts: [],\n            });\n            this.mainRenderPipeline = this.device.createRenderPipeline({\n                layout: this.mainPipelineLayout,\n                vertex: {\n                    module: mainVertex\n                },\n                fragment: {\n                    module: mainFragment,\n                    entryPoint: 'main',\n                    targets: [\n                        { format: 'rgba8unorm' },\n                    ],\n                },\n            });\n        }\n        ;\n    }\n    getDevice(config) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const device = yield this.initializeAPI();\n            if (device) {\n                this.context = this.canvas.getContext('webgpu');\n                const presentationFormat = navigator.gpu.getPreferredCanvasFormat();\n                const canvasConfig = config || {\n                    device: this.device,\n                    format: presentationFormat, // 'bgra8unorm',\n                    usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC\n                };\n                this.context.configure(canvasConfig);\n                return device;\n            }\n        });\n    }\n    initializeAPI() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const entry = navigator.gpu;\n                if (!entry) {\n                    throw \"Cannot initalize WebGPU \";\n                }\n                this.adapter = yield entry.requestAdapter({\n                    powerPreference: \"high-performance\",\n                });\n                this.device = yield this.adapter.requestDevice();\n                this.queue = this.device.queue;\n            }\n            catch (e) {\n                throw \"Cannot initalize WebGPU \";\n            }\n            return this.device;\n        });\n    }\n    addScene(scene) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.scene = scene;\n            // this.renderPipeline = this.device.createRenderPipeline(this.scene.getMesh().pipelineDescriptor());\n            this.textureView = this.context.getCurrentTexture().createView();\n            let entities = this.scene.getBindingGroupEntrys();\n            entities.push({\n                binding: entities.length,\n                resource: this.textureView,\n            });\n        });\n    }\n    draw(time) {\n        this.scene.setUniforms([time], 3); // time\n        this.scene.updateUniformBuffer();\n        this.bindingGroup = this.device.createBindGroup({\n            layout: this.scene.renderPipleline.getBindGroupLayout(0),\n            entries: this.scene.getBindingGroupEntrys(),\n        });\n        this.commandEncoder = this.device.createCommandEncoder();\n        this.context.getCurrentTexture().createView();\n        const renderPassDescriptor = {\n            colorAttachments: [{\n                    loadOp: 'clear',\n                    storeOp: 'store',\n                    view: this.scene.renderTargetView,\n                    clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n                }]\n        };\n        const passEncoder = this.commandEncoder.beginRenderPass(renderPassDescriptor);\n        passEncoder.setPipeline(this.scene.renderPipleline);\n        passEncoder.setVertexBuffer(0, this.scene.getMesh().geometry.vertexBuffer);\n        passEncoder.setBindGroup(0, this.bindingGroup);\n        passEncoder.setIndexBuffer(this.scene.getMesh().geometry.indexBuffer, 'uint16');\n        passEncoder.drawIndexed(this.scene.getMesh().geometry.numOfVerticles, 1);\n        passEncoder.end();\n        this.device.queue.submit([this.commandEncoder.finish()]);\n        const textureView = this.context.getCurrentTexture().createView();\n        const mainbindingGroup = this.device.createBindGroup({\n            layout: this.mainRenderPipeline.getBindGroupLayout(0),\n            entries: this.scene.getBindingGroupEntrys(),\n        });\n        const commandEncoderSecondPass = this.device.createCommandEncoder();\n        // Begin the render pass for the second shader\n        const renderPassDescriptorSecondPass = {\n            colorAttachments: [{\n                    loadOp: 'clear',\n                    storeOp: 'store',\n                    view: textureView,\n                    clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 }, // Adjust as needed\n                }]\n        };\n        const passEncoderSecondPass = commandEncoderSecondPass.beginRenderPass(renderPassDescriptorSecondPass);\n        passEncoderSecondPass.setPipeline(this.mainRenderPipeline); // Use the pipeline for the second shader\n        passEncoderSecondPass.setVertexBuffer(0, this.scene.getMesh().geometry.vertexBuffer);\n        passEncoderSecondPass.setBindGroup(0, mainbindingGroup); // Use the binding group for the second shader\n        // Set other render pass settings and draw commands for the second shader as needed\n        // End the render pass for the second shader\n        passEncoderSecondPass.end();\n        // Finish encoding commands for the second pass\n        const commandBufferSecondPass = commandEncoderSecondPass.finish();\n    }\n    start(t, maxFps = 200, onFrame) {\n        let startTime = null;\n        let lastFrameTime = null; // Track the timestamp of the previous frame\n        this.frame = -1;\n        const renderLoop = (ts) => {\n            if (!startTime) {\n                startTime = ts;\n                lastFrameTime = ts;\n            }\n            const deltaTime = (ts - lastFrameTime);\n            let segment = Math.floor((ts - startTime) / (1000 / maxFps));\n            if (segment > this.frame) {\n                this.frame = segment;\n                if (!this.isPaused)\n                    this.draw(ts / 1000);\n                if (onFrame)\n                    onFrame(this.frame, deltaTime); // Pass deltaTime to the callback\n                this.scene.setUniforms([this.frame], 8);\n            }\n            lastFrameTime = ts; // Update lastFrameTime\n            requestAnimationFrame(renderLoop);\n        };\n        renderLoop(t);\n    }\n    pause() {\n        this.isPaused = !this.isPaused;\n    }\n}\nexports.Renderer = Renderer;\n\n\n//# sourceURL=webpack://demolishedwebgpu/./src/Renderer.js?");

/***/ }),

/***/ "./src/Scene.js":
/*!**********************!*\
  !*** ./src/Scene.js ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Scene = void 0;\nconst TextureLoader_1 = __webpack_require__(/*! ./TextureLoader */ \"./src/TextureLoader.js\");\nclass Scene {\n    getMesh(index = 0) {\n        return Array.from(this.meshes.values())[index];\n    }\n    setDimensions(width, height, dpr = 0) {\n        this.setUniforms([width, height, dpr], 0);\n    }\n    setUniforms(values, offset) {\n        this.uniformBufferArray.set(values, offset);\n    }\n    updateUniformBuffer() {\n        this.device.queue.writeBuffer(this.uniformBuffer, 0, this.uniformBufferArray.buffer, this.uniformBufferArray.byteOffset, this.uniformBufferArray.byteLength);\n    }\n    constructor(key, device, canvas) {\n        this.key = key;\n        this.device = device;\n        this.canvas = canvas;\n        this.meshes = new Map();\n        this.textures = new Array();\n        this.bindingGroupEntrys = new Array();\n        this.renderTargetTexture = this.device.createTexture({\n            size: { width: canvas.width, height: canvas.height, depthOrArrayLayers: 1 },\n            format: \"bgra8unorm\",\n            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n        });\n        this.renderTargetView = this.renderTargetTexture.createView();\n        const dpr = window.devicePixelRatio || 1;\n        this.uniformBuffer = this.device.createBuffer({\n            size: 60,\n            usage: window.GPUBufferUsage.UNIFORM | window.GPUBufferUsage.COPY_DST,\n        });\n        this.uniformBufferArray = new Float32Array([this.canvas.width, this.canvas.height, 0, 1, 0, 0, 0, 0, 0, 0]);\n        canvas.addEventListener(\"mousemove\", (evt) => {\n            if (evt.buttons) {\n                const rect = canvas.getBoundingClientRect();\n                const x = evt.clientX - rect.left;\n                const y = evt.clientY - rect.top;\n                this.setUniforms([x, y, evt.buttons, 0], 4);\n                this.updateUniformBuffer();\n            }\n        });\n    }\n    getBindingGroupEntrys() {\n        const bindingGroupEntrys = [];\n        bindingGroupEntrys.push({\n            binding: 0,\n            resource: {\n                buffer: this.uniformBuffer\n            }\n        });\n        // todo: cache the samplers passed + default sampler ( linearSampler)\n        const sampler = this.device.createSampler({\n            addressModeU: 'repeat',\n            addressModeV: 'repeat',\n            magFilter: 'linear',\n            minFilter: 'nearest'\n        });\n        // add the GPUSampler\n        bindingGroupEntrys.push({\n            binding: 1,\n            resource: sampler\n        });\n        this.textures.forEach((t, i) => {\n            let entry;\n            if (t.type === 0) {\n                entry = {\n                    binding: i + 2,\n                    resource: t.data.createView()\n                };\n            }\n            else {\n                entry = {\n                    binding: i + 2,\n                    resource: this.device.importExternalTexture({ source: t.data }),\n                };\n            }\n            bindingGroupEntrys.push(entry);\n        });\n        return bindingGroupEntrys;\n    }\n    addAssets(textures, samplers) {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (let i = 0; i < textures.length; i++) {\n                const texture = textures[i];\n                if (texture.type == 0) {\n                    this.textures.push({ type: 0, data: yield TextureLoader_1.TextureLoader.createImageTexture(this.device, texture) });\n                }\n                else\n                    this.textures.push({ type: 1, data: yield TextureLoader_1.TextureLoader.createVideoTextue(this.device, texture) });\n            }\n            this.bindingGroupEntrys = [{\n                    binding: 0,\n                    resource: {\n                        buffer: this.uniformBuffer\n                    }\n                }];\n            let textureBindingOffset = (samplers ? samplers.length : 0);\n            if (textures.length > 0 && !samplers) {\n                const sampler = this.device.createSampler({\n                    addressModeU: 'repeat',\n                    addressModeV: 'repeat',\n                    magFilter: 'linear',\n                    minFilter: 'nearest'\n                });\n                this.bindingGroupEntrys.push({\n                    binding: 1,\n                    resource: sampler\n                });\n                textureBindingOffset = 2;\n            }\n            else {\n                samplers.forEach((value, index) => {\n                    const sampler = this.device.createSampler(value);\n                    this.bindingGroupEntrys.push({\n                        binding: index + 1,\n                        resource: sampler\n                    });\n                    textureBindingOffset++;\n                });\n            }\n            this.textures.forEach((t, i) => {\n                let entry;\n                if (t.type === 0) {\n                    entry = {\n                        binding: i + textureBindingOffset,\n                        resource: t.data.createView()\n                    };\n                }\n                else {\n                    entry = {\n                        binding: i + textureBindingOffset,\n                        resource: this.device.importExternalTexture({ source: t.data })\n                    };\n                }\n                this.bindingGroupEntrys.push(entry);\n            });\n        });\n    }\n    addMesh(key, mesh) {\n        this.meshes.set(key, mesh);\n        this.renderPipleline = this.device.createRenderPipeline(this.getMesh().pipelineDescriptor());\n    }\n    removeMesh(key) {\n        return this.meshes.delete(key);\n    }\n}\nexports.Scene = Scene;\n\n\n//# sourceURL=webpack://demolishedwebgpu/./src/Scene.js?");

/***/ }),

/***/ "./src/TextureLoader.js":
/*!******************************!*\
  !*** ./src/TextureLoader.js ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TextureLoader = void 0;\nclass TextureLoader {\n    constructor() {\n    }\n    /**\n     * Load and create an GPUTexture from an Image\n     *\n     * @static\n     * @param {GPUDevice} device\n     * @param {string} texture\n     * @return {*}  {Promise<GPUTexture>}\n     * @memberof TextureLoader\n     */\n    static createImageTexture(device, texture) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const image = new Image();\n            image.src = texture.source;\n            yield image.decode();\n            const imageBitmap = yield createImageBitmap(image);\n            const textureSize = { width: image.width, height: image.height };\n            const gpuTexture = device.createTexture({\n                label: texture.key,\n                size: textureSize,\n                dimension: '2d',\n                format: 'rgba8unorm',\n                usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING\n            });\n            device.queue.copyExternalImageToTexture({\n                source: imageBitmap\n            }, {\n                texture: gpuTexture,\n                mipLevel: 0\n            }, textureSize);\n            return gpuTexture;\n        });\n    }\n    static createVideoTextue(device, texture) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const video = document.createElement(\"video\");\n            video.loop = true;\n            video.autoplay = true;\n            video.muted = true;\n            if (texture.source instanceof MediaStream) {\n                video.srcObject = texture.source;\n            }\n            else\n                video.src = texture.source;\n            yield video.play();\n            return video;\n        });\n    }\n}\nexports.TextureLoader = TextureLoader;\n\n\n//# sourceURL=webpack://demolishedwebgpu/./src/TextureLoader.js?");

/***/ }),

/***/ "./node_modules/yy-fps/dist/fps.es.js":
/*!********************************************!*\
  !*** ./node_modules/yy-fps/dist/fps.es.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FPS: () => (/* binding */ FPS),\n/* harmony export */   defaultFPSOptions: () => (/* binding */ defaultFPSOptions)\n/* harmony export */ });\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\n\nvar defaultFPSOptions = {\n    meter: true,\n    side: 'bottom-right',\n    FPS: 60,\n    tolerance: 1,\n    meterWidth: 100,\n    meterHeight: 25,\n    meterLineHeight: 4,\n    styles: {\n        'background': 'rgba(0, 0, 0, 0.5)',\n        'color': 'white',\n    },\n    stylesFPS: {\n        'padding': '0.1em 0.5em',\n    },\n    text: ' FPS',\n    colorGreen: '#00ff00',\n    colorOrange: '#ffa500',\n    colorRed: '#ff0000',\n    zIndex: 1000,\n};\nvar FPS = /** @class */ (function () {\n    /**\n     * @param [options]\n     * @param [options.meter=true] - include a meter with the FPS\n     * @param [options.side=bottom-right] - include any combination of left/right and top/bottom\n     * @param [options.FPS=60] - desired FPS\n     * @param [options.tolerance=1] - minimum tolerance for fluctuations in FPS number\n     * @param [options.meterWidth=100] - width of meter div\n     * @param [options.meterHeight=25] - height of meter div\n     * @param [options.meterLineHeight=4] - height of meter line\n     * @param [options.styles] - CSS styles to apply to the div (in javascript format)\n     * @param [options.stylesFPS] - CSS styles to apply to the FPS text (in javascript format)\n     * @param [options.stylesMeter] - CSS styles to apply to the FPS meter (in javascript format)\n     * @param [options.text=\" FPS\"] - change the text to the right of the FPS\n     * @param [options.colorGreen=#ffa500] green (good) color on meter\n     * @param [options.colorRed = #ff0000] red (bad) color on meter\n     * @param [options.zIndex = 1000] zIndex to assign to div\n     */\n    function FPS(options) {\n        if (options === void 0) { options = {}; }\n        this.lastTime = 0;\n        this.frameNumber = 0;\n        this.lastFPS = 0;\n        this.options = __assign(__assign({}, defaultFPSOptions), options);\n        this.div = document.createElement('div');\n        this.findParent(this.options.side || 'bottom-right').appendChild(this.div);\n        this.style(this.div, this.options.styles);\n        this.createDivFPS();\n        if (this.options.meter) {\n            this.createDivMeter();\n        }\n    }\n    Object.defineProperty(FPS.prototype, \"fps\", {\n        /** desired FPS */\n        get: function () {\n            return this.options.FPS;\n        },\n        set: function (value) {\n            this.options.FPS = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /** remove meter from DOM */\n    FPS.prototype.remove = function () {\n        this.div.remove();\n    };\n    Object.defineProperty(FPS.prototype, \"meter\", {\n        /** meter (the FPS graph) is on or off */\n        get: function () {\n            return this.options.meter;\n        },\n        set: function (value) {\n            if (value) {\n                this.createDivMeter();\n            }\n            else if (this.meterCanvas) {\n                this.meterCanvas.style.display = 'none';\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    FPS.prototype.style = function (div, style) {\n        for (var entry in style) {\n            div.style[entry] = style[entry];\n        }\n    };\n    FPS.prototype.createDivFPS = function () {\n        var divFPS = document.createElement('div');\n        this.style(divFPS, this.options.stylesFPS);\n        this.div.appendChild(divFPS);\n        this.fpsSpan = document.createElement('span');\n        divFPS.appendChild(this.fpsSpan);\n        var span = document.createElement('span');\n        divFPS.appendChild(span);\n        span.innerText = this.options.text;\n    };\n    FPS.prototype.createDivMeter = function () {\n        if (!this.meterCanvas) {\n            this.meterCanvas = document.createElement('canvas');\n            this.div.appendChild(this.meterCanvas);\n            this.meterCanvas.width = this.options.meterWidth;\n            this.meterCanvas.height = this.options.meterHeight;\n            this.meterCanvas.style.width = this.options.meterWidth + 'px';\n            this.meterCanvas.style.height = this.options.meterHeight + 'px';\n            this.style(this.meterCanvas, this.options.stylesMeter);\n            this.meterContext = this.meterCanvas.getContext('2d', { willReadFrequently: true });\n        }\n        else {\n            this.meterCanvas.style.display = 'block';\n        }\n    };\n    /** call this at the end of the frame to calculate FPS */\n    FPS.prototype.frame = function () {\n        this.frameNumber++;\n        var currentTime = performance.now() - this.lastTime;\n        // skip large differences to remove garbage\n        if (currentTime > 500) {\n            if (this.lastTime !== 0) {\n                this.lastFPS = Math.floor(this.frameNumber / (currentTime / 1000));\n                if (this.lastFPS > this.options.FPS ||\n                    (this.lastFPS >= this.options.FPS - this.options.tolerance &&\n                        this.lastFPS <= this.options.FPS + this.options.tolerance)) {\n                    this.lastFPS = this.options.FPS;\n                }\n            }\n            this.lastTime = performance.now();\n            this.frameNumber = 0;\n        }\n        this.fpsSpan.innerText = this.lastFPS === 0 ? '--' : this.lastFPS + '';\n        if (this.options.meter && this.lastFPS !== 0) {\n            this.meterUpdate(this.lastFPS / this.options.FPS);\n        }\n    };\n    /**\n     * From https://github.com/bgrins/TinyColor#readme\n     * Mix two RGP colors\n     * @param color1 - first color\n     * @param color2 - second color\n     * @param percent - percent to mix\n     */\n    FPS.prototype.mix = function (color1, color2, percent) {\n        var rgb = function (color) {\n            return {\n                r: parseInt(color.substr(1, 2), 16),\n                g: parseInt(color.substr(3, 2), 16),\n                b: parseInt(color.substr(5, 2), 16),\n            };\n        };\n        var digit2 = function (n) {\n            n = Math.floor(n);\n            if (n.toString().length === 1) {\n                return '0' + n.toString(16);\n            }\n            else {\n                return n.toString(16);\n            }\n        };\n        var rgb1 = rgb(color1);\n        var rgb2 = rgb(color2);\n        var r = digit2(rgb1.r * percent + rgb2.r * (1 - percent));\n        var g = digit2(rgb1.g * percent + rgb2.g * (1 - percent));\n        var b = digit2(rgb1.b * percent + rgb2.b * (1 - percent));\n        return \"#\".concat(r).concat(g).concat(b);\n    };\n    FPS.prototype.meterUpdate = function (percent) {\n        var data = this.meterContext.getImageData(0, 0, this.meterCanvas.width, this.meterCanvas.height);\n        this.meterContext.putImageData(data, -1, 0);\n        this.meterContext.clearRect(this.meterCanvas.width - 1, 0, 1, this.meterCanvas.height);\n        if (percent <= 0.5) {\n            this.meterContext.fillStyle = this.mix(this.options.colorRed, this.options.colorOrange, 1 - percent * 2);\n        }\n        else {\n            this.meterContext.fillStyle = this.mix(this.options.colorGreen, this.options.colorOrange, (percent - 0.5) * 2);\n        }\n        var height = (this.meterCanvas.height - this.options.meterLineHeight) * (1 - percent);\n        this.meterContext.fillRect(this.meterCanvas.width - 1, height, 1, this.options.meterLineHeight);\n    };\n    /**\n     * find the parent div for one of the corners\n     * @param side side to place the panel (combination of right/left and bottom/top)\n     * @return {HTMLElement}\n     */\n    FPS.prototype.findParent = function (side) {\n        var styles = [];\n        var name = 'yy-counter-';\n        if (side.indexOf('left') !== -1) {\n            name += 'left-';\n            styles['left'] = 0;\n        }\n        else {\n            name += 'right-';\n            styles['right'] = 0;\n        }\n        if (side.indexOf('top') !== -1) {\n            name += 'top';\n            styles['top'] = 0;\n        }\n        else {\n            name += 'bottom';\n            styles['bottom'] = 0;\n        }\n        var test = document.getElementById(name);\n        if (test) {\n            return test;\n        }\n        var container = document.createElement('div');\n        container.id = name;\n        container.style.overflow = 'hidden';\n        container.style.position = 'fixed';\n        container.style.zIndex = this.options.zIndex.toString();\n        container.style.pointerEvents = 'none';\n        container.style.userSelect = 'none';\n        for (var style in styles) {\n            container.style[style] = styles[style];\n        }\n        document.body.appendChild(container);\n        return container;\n    };\n    return FPS;\n}());\n\n\n//# sourceMappingURL=fps.es.js.map\n\n\n//# sourceURL=webpack://demolishedwebgpu/./node_modules/yy-fps/dist/fps.es.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./example/Example.js");
/******/ 	
/******/ })()
;
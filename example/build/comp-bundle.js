/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./example/ExampleCompute.js":
/*!***********************************!*\
  !*** ./example/ExampleCompute.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Engine_1 = __webpack_require__(/*! ../src/compute/Engine */ \"./src/compute/Engine.js\");\nconst computeRaymarchShader_1 = __webpack_require__(/*! ./shaders/compute/computeRaymarchShader */ \"./example/shaders/compute/computeRaymarchShader.js\");\nconst yy_fps_1 = __webpack_require__(/*! yy-fps */ \"./node_modules/yy-fps/dist/fps.es.js\");\nconst Rectangle_1 = __webpack_require__(/*! ./meshes/Rectangle */ \"./example/meshes/Rectangle.js\");\nconst Material_1 = __webpack_require__(/*! ../src/Material */ \"./src/Material.js\");\nconst Geometry_1 = __webpack_require__(/*! ../src/Geometry */ \"./src/Geometry.js\");\nconst redColorShader_1 = __webpack_require__(/*! ./shaders/wglsl/redColorShader */ \"./example/shaders/wglsl/redColorShader.js\");\ndocument.addEventListener(\"DOMContentLoaded\", () => __awaiter(void 0, void 0, void 0, function* () {\n    const fps = new yy_fps_1.FPS();\n    const renderer = new Engine_1.MyRenderer(document.querySelector(\"canvas\"));\n    yield renderer.init();\n    renderer.addComputePass(\"iChannel0\", computeRaymarchShader_1.computeRaymarchShader);\n    const material = new Material_1.Material(renderer.device, redColorShader_1.redColorShader);\n    const geometry = new Geometry_1.Geometry(renderer.device, Rectangle_1.rectGeometry);\n    renderer.addRenderPass(material, geometry);\n    renderer.start(0, 200, (frame) => {\n        fps.frame();\n    });\n}));\n\n\n//# sourceURL=webpack://demolishedwebgpu/./example/ExampleCompute.js?");

/***/ }),

/***/ "./example/meshes/Rectangle.js":
/*!*************************************!*\
  !*** ./example/meshes/Rectangle.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.rectGeometry = void 0;\nconst Geometry_1 = __webpack_require__(/*! ../../src/Geometry */ \"./src/Geometry.js\");\nexports.rectGeometry = {\n    verticesType: Geometry_1.VERTEXType.xyz,\n    vertices: new Float32Array([\n        -1, 1, 0,\n        -1, -1, 0,\n        1, -1, 0,\n        1, 1, 0,\n        -1, 1, 0,\n        1, -1, 0,\n    ]),\n    indicies: new Uint16Array([0, 1, 2, 3, 4, 5,]),\n};\n\n\n//# sourceURL=webpack://demolishedwebgpu/./example/meshes/Rectangle.js?");

/***/ }),

/***/ "./example/shaders/compute/computeRaymarchShader.js":
/*!**********************************************************!*\
  !*** ./example/shaders/compute/computeRaymarchShader.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.computeRaymarchShader = void 0;\nexports.computeRaymarchShader = ` \r\n\r\n        struct Uniforms {\r\n            resolution: vec3<f32>,\r\n            time: f32\r\n        };\r\n\r\n   \r\n       \r\n        @group(0) @binding(0) var outputTexture: texture_storage_2d<bgra8unorm, write>;\r\n        @group(0) @binding(1) var<uniform> uniforms: Uniforms;\r\n\r\n\r\n        var<workgroup> orb: vec4<f32>;\r\n\r\n        fn rotate(k: vec2<f32>, t: f32) -> vec2<f32> {\r\n            return vec2<f32>(cos(t) * k.x - sin(t) * k.y, sin(t) * k.x + cos(t) * k.y);\r\n        }   \r\n     \r\n        fn map(p: vec3<f32>, s: f32) -> f32 {\r\n            var p_var = p;\r\n            var scale: f32 = 1.;\r\n            orb = vec4<f32>(1000.);\r\n        \r\n            for (var i: i32 = 0; i < 8; i = i + 1) {\r\n                p_var = -1. + 2. * fract(0.5 * p_var + 0.5);\r\n                let r2: f32 = dot(p_var, p_var);\r\n                orb = min(orb, vec4<f32>(abs(p_var), r2));\r\n                let k: f32 = s / r2;\r\n                p_var = p_var * (k);\r\n                scale = scale * (k);\r\n            }\r\n        \r\n            return 0.25 * abs(p_var.y) / scale;\r\n        } \r\n        \r\n        \r\n        fn calcNormal(pos: vec3<f32>, t: f32, s: f32) -> vec3<f32> {\r\n            let precis: f32 = 0.001 * t;\r\n            let e: vec2<f32> = vec2<f32>(1., -1.) * precis;\r\n            return normalize(e.xyy * map(pos + e.xyy, s) + e.yyx * map(pos + e.yyx, s) + e.yxy * map(pos + e.yxy, s) + e.xxx * map(pos + e.xxx, s));\r\n        } \r\n        \r\n        \r\n    \r\n        fn trace(ro: vec3<f32>, rd: vec3<f32>, s: f32) -> f32 {\r\n            var maxd: f32 = 30.;\r\n            var t: f32 = 0.01;\r\n        \r\n            for (var i: i32 = 0; i < 128; i = i + 1) {\r\n                let precis: f32 = 0.001 * t;\r\n                let h: f32 = map(ro + rd * t, s);\r\n                if (h < precis || t > maxd) {\t\tbreak;\r\n         }\r\n                t = t + (h);\r\n            }\r\n        \r\n            if (t > maxd) { t = -1.; }\r\n            return t;\r\n        } \r\n        \r\n    \r\n        fn render(ro: vec3<f32>, rd: vec3<f32>, anim: f32) -> vec3<f32> {\r\n            var col: vec3<f32> = vec3<f32>(0.);\r\n            let t: f32 = trace(ro, rd, anim);\r\n            if (t > 0.) {\r\n                let tra: vec4<f32> = orb;\r\n                let pos: vec3<f32> = ro + t * rd;\r\n                let nor: vec3<f32> = calcNormal(pos, t, anim);\r\n                let light1: vec3<f32> = vec3<f32>(0.577, 0.577, -0.577);\r\n                let light2: vec3<f32> = vec3<f32>(-0.707, 0., 0.707);\r\n                let key: f32 = clamp(dot(light1, nor), 0., 1.);\r\n                let bac: f32 = clamp(0.2 + 0.8 * dot(light2, nor), 0., 1.);\r\n                let amb: f32 = 0.7 + 0.3 * nor.y;\r\n                let ao: f32 = pow(clamp(tra.w * 2., 0., 1.), 1.2);\r\n                var brdf: vec3<f32> = 1. * vec3<f32>(0.4, 0.4, 0.4) * amb * ao;\r\n                brdf = brdf + (1. * vec3<f32>(1., 1., 1.) * key * ao);\r\n                brdf = brdf + (1. * vec3<f32>(0.4, 0.4, 0.4) * bac * ao);\r\n                var rgb: vec3<f32> = vec3<f32>(1.);\r\n                rgb = mix(rgb, vec3<f32>(1., 0.8, 0.2), clamp(6. * tra.y, 0., 1.));\r\n                rgb = mix(rgb, vec3<f32>(1., 0.55, 0.), pow(clamp(1. - 2. * tra.z, 0., 1.), 8.));\r\n                col = rgb * brdf * exp(-0.2 * t);\r\n            }\r\n            return sqrt(col);\r\n        } \r\n        \r\n       \r\n      @compute @workgroup_size(8,8,1) fn main(\r\n        @builtin(global_invocation_id) id : vec3u\r\n      )  {\r\n        \r\n        let resolution = textureDimensions(outputTexture);\r\n        let fragCoord = id.xy;\r\n\r\n\r\n        let uv: vec2<f32> = vec2<f32>(f32(fragCoord.x),f32(fragCoord.y)) / vec2<f32>(f32(resolution.x),f32(resolution.y));\r\n\r\n        let time: f32 = (uniforms.time * 0.25);\r\n        let anim: f32 = 1.1 + 0.5 * smoothstep(-0.3, 0.3, cos(0.1 * time));\r\n    \r\n\r\n        let q: vec2<f32> = (vec2<f32>(f32(fragCoord.x), f32(fragCoord.y)) + vec2<f32>(1.0, 1.0)) / 2.0;\r\n\r\n\r\n        let p: vec2<f32> = (2. * q - vec2<f32>(resolution.xy)) / f32(resolution.y);\r\n\r\n\r\n//        let p: vec2<f32> = (2. * q - resolution.xy) / resolution.y;\r\n\r\n        let ro: vec3<f32> = vec3<f32>(2.8 * cos(0.1 + 0.33 * time), 0.4 + 0.3 * cos(0.37 * time), 2.8 * cos(0.5 + 0.35 * time));\r\n        let ta: vec3<f32> = vec3<f32>(1.9 * cos(1.2 + 0.41 * time), 0.4 + 0.1 * cos(0.27 * time), 1.9 * cos(2. + 0.38 * time));\r\n        \r\n        let roll: f32 = 0.2 * cos(0.1 * time);\r\n        let cw: vec3<f32> = normalize(ta - ro);\r\n        let cp: vec3<f32> = vec3<f32>(sin(roll), cos(roll), 0.);\r\n        let cu: vec3<f32> = normalize(cross(cw, cp));\r\n        let cv: vec3<f32> = normalize(cross(cu, cw));\r\n        let rd: vec3<f32> = normalize(p.x * cu + p.y * cv + 2. * cw);\r\n\r\n        let tot = render(ro, rd, anim);       \r\n\r\n        let color = vec4f(tot.rgb, 1);     \r\n   \r\n        textureStore(outputTexture, fragCoord, color);\r\n\r\n      }\r\n    `;\n\n\n//# sourceURL=webpack://demolishedwebgpu/./example/shaders/compute/computeRaymarchShader.js?");

/***/ }),

/***/ "./example/shaders/wglsl/redColorShader.js":
/*!*************************************************!*\
  !*** ./example/shaders/wglsl/redColorShader.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.redColorShader = void 0;\nconst Material_1 = __webpack_require__(/*! ../../../src/Material */ \"./src/Material.js\");\nexports.redColorShader = {\n    vertex: Material_1.defaultWglslVertex,\n    fragment: /* wgsl */ `\r\n  \r\n  struct Uniforms {\r\n    resolution: vec3<f32>,\r\n    time: f32\r\n  };\r\n\r\n  @group(0) @binding(0) var screen_sampler : sampler;\r\n  @group(0) @binding(1) var color_buffer : texture_2d<f32>;\r\n  @group(0) @binding(2) var<uniform> uniforms: Uniforms;\r\n\r\n     \r\n  struct VertexOutput {\r\n    @builtin(position) pos: vec4<f32>,\r\n    @location(0) uv: vec2<f32>\r\n  };  \r\n\r\n  fn main(fragCoord: vec2<f32>) -> vec4<f32> {\r\n    var col: vec3<f32> = vec3<f32>(1.0,0.0,0.0); \r\n    var result:vec4<f32> = vec4<f32>(col,1.0);\r\n   return result; \r\n  \r\n  }\r\n  @fragment\r\n  fn main_fragment(in: VertexOutput) -> @location(0) vec4<f32> {      \r\n    return main(in.uv);\r\n}`\n};\n\n\n//# sourceURL=webpack://demolishedwebgpu/./example/shaders/wglsl/redColorShader.js?");

/***/ }),

/***/ "./src/Geometry.js":
/*!*************************!*\
  !*** ./src/Geometry.js ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Geometry = exports.DefaultIndicies = exports.VERTEXType = void 0;\nvar VERTEXType;\n(function (VERTEXType) {\n    VERTEXType[VERTEXType[\"xyz\"] = 3] = \"xyz\";\n    VERTEXType[VERTEXType[\"xyzw\"] = 4] = \"xyzw\";\n    VERTEXType[VERTEXType[\"xyzrgba\"] = 7] = \"xyzrgba\";\n    VERTEXType[VERTEXType[\"xyzwrgba\"] = 8] = \"xyzwrgba\";\n})(VERTEXType || (exports.VERTEXType = VERTEXType = {}));\nexports.DefaultIndicies = new Uint16Array([0, 1, 2, 3, 4, 5]);\n// let createBuffer = (arr: Float32Array | Uint16Array, usage: number) => {\n//     let desc = {\n//         size: (arr.byteLength + 3) & ~3,\n//         usage,\n//         mappedAtCreation: true\n//     };\n//     let buffer = this.device.createBuffer(desc);\n//     const writeArray =\n//         arr instanceof Uint16Array\n//             ? new Uint16Array(buffer.getMappedRange())\n//             : new Float32Array(buffer.getMappedRange());\n//     writeArray.set(arr);\n//     buffer.unmap();\n//     return buffer;\n//};\nclass Geometry {\n    createBuffer(arr, usage, vertexSize) {\n        let desc = {\n            size: (arr.byteLength + vertexSize) & ~vertexSize,\n            usage,\n            mappedAtCreation: true\n        };\n        let buffer = this.device.createBuffer(desc);\n        const writeArray = arr instanceof Uint16Array\n            ? new Uint16Array(buffer.getMappedRange())\n            : new Float32Array(buffer.getMappedRange());\n        writeArray.set(arr);\n        buffer.unmap();\n        return buffer;\n    }\n    constructor(device, model) {\n        this.device = device;\n        this.model = model;\n        this.vertexBuffer = this.createBuffer(model.vertices, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST, model.verticesType);\n        this.indexBuffer = this.createBuffer(model.indicies, GPUBufferUsage.INDEX, 3);\n        this.numOfVerticles = model.vertices.length / model.verticesType;\n    }\n    vertexBufferLayout(shaderLocation) {\n        const vertexBufferLayout = {\n            attributes: [{\n                    shaderLocation: shaderLocation,\n                    offset: 0,\n                    format: 'float32x2'\n                }],\n            arrayStride: 4 * this.model.verticesType,\n            stepMode: 'vertex'\n        };\n        return vertexBufferLayout;\n    }\n}\nexports.Geometry = Geometry;\n\n\n//# sourceURL=webpack://demolishedwebgpu/./src/Geometry.js?");

/***/ }),

/***/ "./src/Material.js":
/*!*************************!*\
  !*** ./src/Material.js ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Material = exports.defaultWglslVertex = void 0;\nexports.defaultWglslVertex = `  \r\nstruct VertexInput {\r\n  @location(0) pos: vec2<f32>,\r\n  @builtin(vertex_index) index : u32\r\n};  \r\nstruct VertexOutput {\r\n  @builtin(position) pos: vec4<f32>,\r\n  @location(0) uv: vec2<f32>,\r\n};  \r\n\r\n@vertex\r\nfn main_vertex(input:VertexInput) -> VertexOutput {\r\n\r\n    var output: VertexOutput;\r\n\r\n\r\n    var pos: vec2<f32> = input.pos * 2.0 - 1.0;\r\n    output.pos = vec4<f32>(pos, 0.0, 1.0);\r\n    output.uv = pos;\r\n\r\n\r\n    // var vtx = array<vec3<f32>, 6>(\r\n    //   vec3<f32>(-1.0,  1.0, 0.0),\r\n    //   vec3<f32>(-1.0, -1.0, 0.0),\r\n    //   vec3<f32>( 1.0, -1.0, 0.0),\r\n    //   vec3<f32>( 1.0,  1.0, 0.0),\r\n    //   vec3<f32>(-1.0,  1.0, 0.0),\r\n    //   vec3<f32>( 1.0, -1.0, 0.0),\r\n    // );\r\n\r\n     // var uv:vec2<f32> = vec2<f32>(vtx[i].x,vtx[i].y);\r\n\r\n      // var pos = 2.0 * uv - vec2<f32>(1.0);\r\n      // output.pos =   vec4<f32>(pos.xy,1., 1.0) ;\r\n      // output.uv = vec2<f32>(0.);\r\n\r\n  return output;\r\n}`;\nclass Material {\n    constructor(device, shader) {\n        this.device = device;\n        this.shader = shader;\n        this.vertexShaderModule = this.device.createShaderModule({\n            code: shader.vertex\n        });\n        this.fragmentShaderModule = this.device.createShaderModule({\n            code: shader.fragment\n        });\n    }\n    static createMaterialShader(vertex, fragment, vertexEntryPoint, fragmentEntryPoint) {\n        const material = {\n            fragment: fragment,\n            fragmentEntryPoint: fragmentEntryPoint,\n            vertex: vertex,\n            vertexEntryPoint: vertexEntryPoint\n        };\n        return material;\n    }\n}\nexports.Material = Material;\n\n\n//# sourceURL=webpack://demolishedwebgpu/./src/Material.js?");

/***/ }),

/***/ "./src/compute/Engine.js":
/*!*******************************!*\
  !*** ./src/compute/Engine.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MyRenderer = exports.MyComputeShader = exports.PassBuilder = exports.Uniforms = exports.PassBase = void 0;\nclass PassBase {\n    constructor(device) {\n    }\n}\nexports.PassBase = PassBase;\nclass Uniforms {\n    constructor(device, canvas) {\n        this.device = device;\n        this.uniformBuffer = this.device.createBuffer({\n            size: 40,\n            usage: window.GPUBufferUsage.UNIFORM | window.GPUBufferUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\n        });\n        this.uniformBufferArray = new Float32Array([canvas.width, canvas.height, 0, 1.0]);\n    }\n    bindingGroupEntry(index) {\n        return { binding: 1, resource: { buffer: this.uniformBuffer } };\n    }\n    setUniforms(values, offset) {\n        this.uniformBufferArray.set(values, offset); // time \n    }\n    updateUniformBuffer() {\n        this.device.queue.writeBuffer(this.uniformBuffer, 0, this.uniformBufferArray.buffer, this.uniformBufferArray.byteOffset, this.uniformBufferArray.byteLength);\n    }\n}\nexports.Uniforms = Uniforms;\nclass PassBuilder extends PassBase {\n    constructor(device, canvas) {\n        super(device);\n        this.canvas = canvas;\n        this.device = device;\n    }\n    getRenderPiplelineBindingGroupLayout(uniformBuffer, sampler) {\n        const bindingGroupEntrys = [];\n        bindingGroupEntrys.push({\n            binding: 0,\n            resource: {\n                buffer: uniformBuffer\n            }\n        });\n        // todo: cache the samplers passed + default sampler ( linearSampler)\n        const defaultSampler = this.device.createSampler({\n            addressModeU: 'repeat',\n            addressModeV: 'repeat',\n            magFilter: 'linear',\n            minFilter: 'nearest'\n        });\n        // add the GPUSampler\n        bindingGroupEntrys.push({\n            binding: 1,\n            resource: sampler || defaultSampler\n        });\n        return bindingGroupEntrys;\n    }\n    createComputePipeline(computeShader) {\n        const bindGroupLayout = this.device.createBindGroupLayout({\n            entries: [\n                { binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    storageTexture: {\n                        access: \"write-only\",\n                        format: \"bgra8unorm\",\n                        viewDimension: \"2d\"\n                    },\n                },\n                { binding: 1, visibility: GPUShaderStage.COMPUTE,\n                    buffer: {\n                        type: \"uniform\"\n                    }\n                }\n            ],\n        });\n        const pipeline = this.device.createComputePipeline({\n            layout: this.device.createPipelineLayout({\n                bindGroupLayouts: [bindGroupLayout],\n            }),\n            compute: {\n                module: computeShader.shaderModule,\n                entryPoint: 'main',\n            },\n        });\n        return pipeline;\n    }\n}\nexports.PassBuilder = PassBuilder;\nclass MyComputeShader {\n    constructor(device, computeShaderCode) {\n        this.device = device;\n        this.shaderModule = this.device.createShaderModule({ code: computeShaderCode });\n    }\n}\nexports.MyComputeShader = MyComputeShader;\nclass MyRenderer {\n    constructor(canvas) {\n        this.canvas = canvas;\n        this.passBacklog = new Map();\n    }\n    init() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const adapter = yield ((_a = navigator.gpu) === null || _a === void 0 ? void 0 : _a.requestAdapter());\n            const hasBGRA8unormStorage = adapter.features.has('bgra8unorm-storage');\n            const device = yield (adapter === null || adapter === void 0 ? void 0 : adapter.requestDevice({\n                requiredFeatures: hasBGRA8unormStorage\n                    ? ['bgra8unorm-storage']\n                    : [],\n            }));\n            if (!device) {\n                throw \"need a browser that supports WebGPU\";\n            }\n            const presentationFormat = hasBGRA8unormStorage\n                ? navigator.gpu.getPreferredCanvasFormat()\n                : 'rgba8unorm';\n            const context = this.canvas.getContext(\"webgpu\");\n            context.configure({\n                device,\n                format: presentationFormat,\n                usage: GPUTextureUsage.TEXTURE_BINDING |\n                    GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT,\n            });\n            this.passBuilder = new PassBuilder(device, this.canvas);\n            this.context = context;\n            this.device = device;\n            this.createAssets();\n        });\n    }\n    createRenderPipeline(uniformBuffer, material, geometry) {\n        const bindingGroupEntrys = [];\n        bindingGroupEntrys.push({\n            binding: 0,\n            resource: {\n                buffer: uniformBuffer\n            }\n        });\n        const sampler = this.device.createSampler({\n            addressModeU: 'repeat',\n            addressModeV: 'repeat',\n            magFilter: 'linear',\n            minFilter: 'nearest'\n        });\n        // add the GPUSampler\n        bindingGroupEntrys.push({\n            binding: 1,\n            resource: sampler\n        });\n        bindingGroupEntrys.push({\n            binding: 1,\n            resource: this.compueBufferView\n        });\n        const screen_bind_group_layout = this.device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    sampler: {}\n                },\n                {\n                    binding: 1,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    texture: {}\n                },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.FRAGMENT,\n                    buffer: {\n                        type: \"uniform\"\n                    }\n                },\n            ]\n        });\n        this.screen_bind_group = this.device.createBindGroup({\n            layout: screen_bind_group_layout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: this.sampler\n                },\n                {\n                    binding: 1,\n                    resource: this.compueBufferView\n                },\n                {\n                    binding: 2,\n                    resource: {\n                        buffer: uniformBuffer\n                    }\n                }\n            ]\n        });\n        const screen_pipeline_layout = this.device.createPipelineLayout({\n            bindGroupLayouts: [screen_bind_group_layout]\n        });\n        const pipelineDescriptor = {\n            vertex: {\n                module: material.vertexShaderModule,\n                entryPoint: material.shader.vertexEntryPoint || 'main_vertex',\n                buffers: [geometry.vertexBufferLayout(0)]\n            },\n            fragment: {\n                module: material.fragmentShaderModule,\n                entryPoint: material.shader.fragmentEntryPoint || 'main_fragment',\n                targets: [{\n                        format: 'bgra8unorm'\n                    }]\n            },\n            primitive: {\n                topology: 'triangle-list',\n            },\n            layout: screen_pipeline_layout\n        };\n        return this.device.createRenderPipeline(pipelineDescriptor);\n    }\n    createAssets() {\n        this.computeBuffer = this.device.createTexture({\n            size: {\n                width: this.canvas.width,\n                height: this.canvas.height,\n            },\n            format: \"bgra8unorm\",\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT\n        });\n        this.compueBufferView = this.computeBuffer.createView();\n        const samplerDescriptor = {\n            addressModeU: \"repeat\",\n            addressModeV: \"repeat\",\n            magFilter: \"linear\",\n            minFilter: \"nearest\",\n            mipmapFilter: \"nearest\",\n            maxAnisotropy: 1\n        };\n        this.sampler = this.device.createSampler(samplerDescriptor);\n    }\n    addRenderPass(material, geometry) {\n        // set up the renderpipleline\n        let uniforms = new Uniforms(this.device, this.canvas);\n        this.renderPipleline = this.createRenderPipeline(uniforms.uniformBuffer, material, geometry);\n        this.geometry = geometry;\n    }\n    addComputePass(label, compteShaderCode) {\n        const shaderModule = new MyComputeShader(this.device, compteShaderCode);\n        const computePipeline = this.passBuilder.createComputePipeline(shaderModule);\n        const uniforms = new Uniforms(this.device, this.canvas);\n        const bindingGroupEntrys = [];\n        bindingGroupEntrys.push({ binding: 0,\n            resource: this.compueBufferView\n        });\n        bindingGroupEntrys.push({\n            binding: 1,\n            resource: {\n                buffer: uniforms.uniformBuffer\n            }\n        });\n        const bindGroup = this.device.createBindGroup({\n            layout: computePipeline.getBindGroupLayout(0),\n            entries: bindingGroupEntrys\n        });\n        this.passBacklog.set(0, {\n            label: label,\n            pipleline: computePipeline,\n            uniforms: new Uniforms(this.device, this.canvas),\n            bindGroup: bindGroup\n        });\n    }\n    update(ts) {\n        const pass = this.passBacklog.get(0);\n        pass.uniforms.setUniforms([ts], 3); // time        \n        pass.uniforms.updateUniformBuffer();\n        const encoder = this.device.createCommandEncoder({ label: `Ecoder for ${pass.label} ` });\n        const computePass = encoder.beginComputePass();\n        computePass.setPipeline(pass.pipleline);\n        computePass.setBindGroup(0, pass.bindGroup);\n        computePass.dispatchWorkgroups(Math.floor((this.canvas.width + 7) / 8), Math.floor((this.canvas.height + 7) / 8), 1);\n        computePass.end();\n        const textureView = this.context.getCurrentTexture().createView();\n        const renderpass = encoder.beginRenderPass({\n            colorAttachments: [{\n                    view: textureView,\n                    clearValue: { r: 0.5, g: 0.0, b: 0.25, a: 1.0 },\n                    loadOp: \"clear\",\n                    storeOp: \"store\"\n                }]\n        });\n        renderpass.setPipeline(this.renderPipleline);\n        renderpass.setVertexBuffer(0, this.geometry.vertexBuffer);\n        renderpass.setBindGroup(0, this.screen_bind_group);\n        renderpass.setIndexBuffer(this.geometry.indexBuffer, 'uint16');\n        renderpass.drawIndexed(this.geometry.numOfVerticles, 1);\n        renderpass.end();\n        this.device.queue.submit([encoder.finish()]);\n    }\n    start(t, maxFps = 200, onFrame) {\n        let startTime = null;\n        let frame = -1;\n        const renderLoop = (ts) => {\n            if (!startTime)\n                startTime = ts;\n            let segment = Math.floor((ts - startTime) / (1000 / maxFps));\n            if (segment > frame) {\n                frame = segment;\n                this.frame = frame;\n                if (!this.isPaused)\n                    this.update(ts / 1000);\n                if (onFrame)\n                    onFrame(frame);\n            }\n            requestAnimationFrame(renderLoop);\n        };\n        renderLoop(t);\n    }\n    pause() {\n        this.isPaused = !this.isPaused;\n    }\n}\nexports.MyRenderer = MyRenderer;\n\n\n//# sourceURL=webpack://demolishedwebgpu/./src/compute/Engine.js?");

/***/ }),

/***/ "./node_modules/yy-fps/dist/fps.es.js":
/*!********************************************!*\
  !*** ./node_modules/yy-fps/dist/fps.es.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FPS: () => (/* binding */ FPS),\n/* harmony export */   defaultFPSOptions: () => (/* binding */ defaultFPSOptions)\n/* harmony export */ });\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\n\nvar defaultFPSOptions = {\n    meter: true,\n    side: 'bottom-right',\n    FPS: 60,\n    tolerance: 1,\n    meterWidth: 100,\n    meterHeight: 25,\n    meterLineHeight: 4,\n    styles: {\n        'background': 'rgba(0, 0, 0, 0.5)',\n        'color': 'white',\n    },\n    stylesFPS: {\n        'padding': '0.1em 0.5em',\n    },\n    text: ' FPS',\n    colorGreen: '#00ff00',\n    colorOrange: '#ffa500',\n    colorRed: '#ff0000',\n    zIndex: 1000,\n};\nvar FPS = /** @class */ (function () {\n    /**\n     * @param [options]\n     * @param [options.meter=true] - include a meter with the FPS\n     * @param [options.side=bottom-right] - include any combination of left/right and top/bottom\n     * @param [options.FPS=60] - desired FPS\n     * @param [options.tolerance=1] - minimum tolerance for fluctuations in FPS number\n     * @param [options.meterWidth=100] - width of meter div\n     * @param [options.meterHeight=25] - height of meter div\n     * @param [options.meterLineHeight=4] - height of meter line\n     * @param [options.styles] - CSS styles to apply to the div (in javascript format)\n     * @param [options.stylesFPS] - CSS styles to apply to the FPS text (in javascript format)\n     * @param [options.stylesMeter] - CSS styles to apply to the FPS meter (in javascript format)\n     * @param [options.text=\" FPS\"] - change the text to the right of the FPS\n     * @param [options.colorGreen=#ffa500] green (good) color on meter\n     * @param [options.colorRed = #ff0000] red (bad) color on meter\n     * @param [options.zIndex = 1000] zIndex to assign to div\n     */\n    function FPS(options) {\n        if (options === void 0) { options = {}; }\n        this.lastTime = 0;\n        this.frameNumber = 0;\n        this.lastFPS = 0;\n        this.options = __assign(__assign({}, defaultFPSOptions), options);\n        this.div = document.createElement('div');\n        this.findParent(this.options.side || 'bottom-right').appendChild(this.div);\n        this.style(this.div, this.options.styles);\n        this.createDivFPS();\n        if (this.options.meter) {\n            this.createDivMeter();\n        }\n    }\n    Object.defineProperty(FPS.prototype, \"fps\", {\n        /** desired FPS */\n        get: function () {\n            return this.options.FPS;\n        },\n        set: function (value) {\n            this.options.FPS = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /** remove meter from DOM */\n    FPS.prototype.remove = function () {\n        this.div.remove();\n    };\n    Object.defineProperty(FPS.prototype, \"meter\", {\n        /** meter (the FPS graph) is on or off */\n        get: function () {\n            return this.options.meter;\n        },\n        set: function (value) {\n            if (value) {\n                this.createDivMeter();\n            }\n            else if (this.meterCanvas) {\n                this.meterCanvas.style.display = 'none';\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    FPS.prototype.style = function (div, style) {\n        for (var entry in style) {\n            div.style[entry] = style[entry];\n        }\n    };\n    FPS.prototype.createDivFPS = function () {\n        var divFPS = document.createElement('div');\n        this.style(divFPS, this.options.stylesFPS);\n        this.div.appendChild(divFPS);\n        this.fpsSpan = document.createElement('span');\n        divFPS.appendChild(this.fpsSpan);\n        var span = document.createElement('span');\n        divFPS.appendChild(span);\n        span.innerText = this.options.text;\n    };\n    FPS.prototype.createDivMeter = function () {\n        if (!this.meterCanvas) {\n            this.meterCanvas = document.createElement('canvas');\n            this.div.appendChild(this.meterCanvas);\n            this.meterCanvas.width = this.options.meterWidth;\n            this.meterCanvas.height = this.options.meterHeight;\n            this.meterCanvas.style.width = this.options.meterWidth + 'px';\n            this.meterCanvas.style.height = this.options.meterHeight + 'px';\n            this.style(this.meterCanvas, this.options.stylesMeter);\n            this.meterContext = this.meterCanvas.getContext('2d', { willReadFrequently: true });\n        }\n        else {\n            this.meterCanvas.style.display = 'block';\n        }\n    };\n    /** call this at the end of the frame to calculate FPS */\n    FPS.prototype.frame = function () {\n        this.frameNumber++;\n        var currentTime = performance.now() - this.lastTime;\n        // skip large differences to remove garbage\n        if (currentTime > 500) {\n            if (this.lastTime !== 0) {\n                this.lastFPS = Math.floor(this.frameNumber / (currentTime / 1000));\n                if (this.lastFPS > this.options.FPS ||\n                    (this.lastFPS >= this.options.FPS - this.options.tolerance &&\n                        this.lastFPS <= this.options.FPS + this.options.tolerance)) {\n                    this.lastFPS = this.options.FPS;\n                }\n            }\n            this.lastTime = performance.now();\n            this.frameNumber = 0;\n        }\n        this.fpsSpan.innerText = this.lastFPS === 0 ? '--' : this.lastFPS + '';\n        if (this.options.meter && this.lastFPS !== 0) {\n            this.meterUpdate(this.lastFPS / this.options.FPS);\n        }\n    };\n    /**\n     * From https://github.com/bgrins/TinyColor#readme\n     * Mix two RGP colors\n     * @param color1 - first color\n     * @param color2 - second color\n     * @param percent - percent to mix\n     */\n    FPS.prototype.mix = function (color1, color2, percent) {\n        var rgb = function (color) {\n            return {\n                r: parseInt(color.substr(1, 2), 16),\n                g: parseInt(color.substr(3, 2), 16),\n                b: parseInt(color.substr(5, 2), 16),\n            };\n        };\n        var digit2 = function (n) {\n            n = Math.floor(n);\n            if (n.toString().length === 1) {\n                return '0' + n.toString(16);\n            }\n            else {\n                return n.toString(16);\n            }\n        };\n        var rgb1 = rgb(color1);\n        var rgb2 = rgb(color2);\n        var r = digit2(rgb1.r * percent + rgb2.r * (1 - percent));\n        var g = digit2(rgb1.g * percent + rgb2.g * (1 - percent));\n        var b = digit2(rgb1.b * percent + rgb2.b * (1 - percent));\n        return \"#\".concat(r).concat(g).concat(b);\n    };\n    FPS.prototype.meterUpdate = function (percent) {\n        var data = this.meterContext.getImageData(0, 0, this.meterCanvas.width, this.meterCanvas.height);\n        this.meterContext.putImageData(data, -1, 0);\n        this.meterContext.clearRect(this.meterCanvas.width - 1, 0, 1, this.meterCanvas.height);\n        if (percent <= 0.5) {\n            this.meterContext.fillStyle = this.mix(this.options.colorRed, this.options.colorOrange, 1 - percent * 2);\n        }\n        else {\n            this.meterContext.fillStyle = this.mix(this.options.colorGreen, this.options.colorOrange, (percent - 0.5) * 2);\n        }\n        var height = (this.meterCanvas.height - this.options.meterLineHeight) * (1 - percent);\n        this.meterContext.fillRect(this.meterCanvas.width - 1, height, 1, this.options.meterLineHeight);\n    };\n    /**\n     * find the parent div for one of the corners\n     * @param side side to place the panel (combination of right/left and bottom/top)\n     * @return {HTMLElement}\n     */\n    FPS.prototype.findParent = function (side) {\n        var styles = [];\n        var name = 'yy-counter-';\n        if (side.indexOf('left') !== -1) {\n            name += 'left-';\n            styles['left'] = 0;\n        }\n        else {\n            name += 'right-';\n            styles['right'] = 0;\n        }\n        if (side.indexOf('top') !== -1) {\n            name += 'top';\n            styles['top'] = 0;\n        }\n        else {\n            name += 'bottom';\n            styles['bottom'] = 0;\n        }\n        var test = document.getElementById(name);\n        if (test) {\n            return test;\n        }\n        var container = document.createElement('div');\n        container.id = name;\n        container.style.overflow = 'hidden';\n        container.style.position = 'fixed';\n        container.style.zIndex = this.options.zIndex.toString();\n        container.style.pointerEvents = 'none';\n        container.style.userSelect = 'none';\n        for (var style in styles) {\n            container.style[style] = styles[style];\n        }\n        document.body.appendChild(container);\n        return container;\n    };\n    return FPS;\n}());\n\n\n//# sourceMappingURL=fps.es.js.map\n\n\n//# sourceURL=webpack://demolishedwebgpu/./node_modules/yy-fps/dist/fps.es.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./example/ExampleCompute.js");
/******/ 	
/******/ })()
;
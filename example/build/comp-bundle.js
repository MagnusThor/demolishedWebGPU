/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./example/Example.js":
/*!****************************!*\
  !*** ./example/Example.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst yy_fps_1 = __webpack_require__(/*! yy-fps */ \"./node_modules/yy-fps/dist/fps.es.js\");\nconst ComputeRenderer_1 = __webpack_require__(/*! ../src/engine/ComputeRenderer */ \"./src/engine/ComputeRenderer.js\");\nconst ITexture_1 = __webpack_require__(/*! ../src/interface/ITexture */ \"./src/interface/ITexture.js\");\nconst raytracedRollingBallShader_1 = __webpack_require__(/*! ./shaders/wglsl/raytracedRollingBallShader */ \"./example/shaders/wglsl/raytracedRollingBallShader.js\");\nconst Rectangle_1 = __webpack_require__(/*! ./meshes/Rectangle */ \"./example/meshes/Rectangle.js\");\nconst customMainShader_1 = __webpack_require__(/*! ./shaders/shared/customMainShader */ \"./example/shaders/shared/customMainShader.js\");\nconst Material_1 = __webpack_require__(/*! ../src/engine/Material */ \"./src/engine/Material.js\");\nconst Geometry_1 = __webpack_require__(/*! ../src/engine/Geometry */ \"./src/engine/Geometry.js\");\ndocument.addEventListener(\"DOMContentLoaded\", () => __awaiter(void 0, void 0, void 0, function* () {\n    const textures = [\n        {\n            key: \"iChannel0\",\n            source: \"assets/noise2.png\", // ms \n            type: ITexture_1.TextureType.IMAGE,\n        }\n    ];\n    const fps = new yy_fps_1.FPS();\n    const renderer = new ComputeRenderer_1.ComputeRenderer(document.querySelector(\"canvas\"));\n    yield renderer.init();\n    const geometry = new Geometry_1.Geometry(renderer.device, Rectangle_1.rectGeometry);\n    // add a frag shader ()\n    // const iChannel0Shader = new Material(renderer.device,redColorShader);\n    // await renderer.addRenderPass(\"iChannel0\",iChannel0Shader,geometry,textures).catch (err => {\n    //     console.log(err);\n    // });\n    // add a frag shader ()\n    //const iChannel1Shader = new Material(renderer.device,blueColorShader);\n    // await renderer.addRenderPass(\"iChannel1\",iChannel1Shader,geometry).catch (err => {\n    //     console.log(err);\n    // });\n    const material = new Material_1.Material(renderer.device, raytracedRollingBallShader_1.raytracedRollingBallShader);\n    yield renderer.addRenderPass(\"iChannel0\", material, geometry, textures).catch(err => {\n        console.log(err);\n    });\n    // add a compte shader ( )\n    //await renderer.addComputeRenderPass(\"iChannel2\", computeRaymarchShader,[]);\n    renderer.addMainPass(new Material_1.Material(renderer.device, customMainShader_1.customMainShader));\n    renderer.start(0, 200, (frame) => {\n        fps.frame();\n    });\n}));\n\n\n//# sourceURL=webpack://demolishedwebgpu/./example/Example.js?");

/***/ }),

/***/ "./example/meshes/Rectangle.js":
/*!*************************************!*\
  !*** ./example/meshes/Rectangle.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.rectGeometry = void 0;\nconst Geometry_1 = __webpack_require__(/*! ../../src/engine/Geometry */ \"./src/engine/Geometry.js\");\nexports.rectGeometry = {\n    verticesType: Geometry_1.VERTEXType.xyz,\n    vertices: new Float32Array([\n        -1, 1, 0,\n        -1, -1, 0,\n        1, -1, 0,\n        1, 1, 0,\n        -1, 1, 0,\n        1, -1, 0,\n    ]),\n    indicies: new Uint16Array([0, 1, 2, 3, 4, 5]),\n};\n\n\n//# sourceURL=webpack://demolishedwebgpu/./example/meshes/Rectangle.js?");

/***/ }),

/***/ "./example/shaders/shared/customMainShader.js":
/*!****************************************************!*\
  !*** ./example/shaders/shared/customMainShader.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.customMainShader = void 0;\nexports.customMainShader = {\n    vertex: /* wgsl */ `\r\n  \r\n  struct VertexOutput {\r\n    @builtin(position) Position  : vec4<f32>,\r\n    @location(0) TexCoord  : vec2<f32>,\r\n}\r\n\r\n@vertex\r\nfn main_vertex(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\r\n\r\n    var positions = array<vec2<f32>, 6>(\r\n        vec2<f32>( 1.0,  1.0),\r\n        vec2<f32>( 1.0, -1.0),\r\n        vec2<f32>(-1.0, -1.0),\r\n        vec2<f32>( 1.0,  1.0),\r\n        vec2<f32>(-1.0, -1.0),\r\n        vec2<f32>(-1.0,  1.0)\r\n    );\r\n\r\n    var texCoords = array<vec2<f32>, 6>(\r\n        vec2<f32>(1.0, 0.0),\r\n        vec2<f32>(1.0, 1.0),\r\n        vec2<f32>(0.0, 1.0),\r\n        vec2<f32>(1.0, 0.0),\r\n        vec2<f32>(0.0, 1.0),\r\n        vec2<f32>(0.0, 0.0)\r\n    );\r\n\r\n    var output : VertexOutput;\r\n    output.Position = vec4<f32>(positions[VertexIndex], 0.0, 1.0);\r\n    output.TexCoord = texCoords[VertexIndex];\r\n    return output;\r\n}\r\n  \r\n  `,\n    fragment: /* wgsl */ `\r\n  \r\n  struct Uniforms {\r\n    resolution: vec3<f32>,\r\n    time: f32\r\n  };\r\n\r\n  @group(0) @binding(0) var screen_sampler : sampler;\r\n  @group(0) @binding(1) var<uniform> uniforms: Uniforms;\r\n  @group(0) @binding(2) var iChannel0: texture_2d<f32>; \r\n  @group(0) @binding(3) var iChannel1: texture_2d<f32>; \r\n  @group(0) @binding(4) var iChannel2: texture_2d<f32>; \r\n  \r\n  \r\n  struct VertexOutput {\r\n    @builtin(position) Position: vec4<f32>,\r\n    @location(0) TexCoord: vec2<f32>\r\n  };  \r\n\r\n  fn sample_texture(tex: texture_2d<f32>, uv: vec2<f32>) -> vec4<f32> {\r\n    let result: vec4<f32> = textureSample(tex, screen_sampler, uv);\r\n    return result;\r\n}\r\n\r\nfn DpthFld(iCh: texture_2d<f32>, uv: vec2<f32>) -> vec3<f32> {\r\n    let focD: f32 = 3.5;\r\n    let coc: f32 = 2.0;\r\n    let l: f32 = abs(sample_texture(iChannel0, uv).w - focD - coc) - coc;\r\n    let dof: f32 = clamp(l / coc, 0.0, 1.0);\r\n    var acc: vec3<f32> = vec3<f32>(0.0);\r\n    for (var i: i32 = 0; i < 25; i = i + 1) {\r\n        let offset: vec2<f32> = (vec2<f32>(f32(i) / 5.0, f32(i % 5)) - vec2<f32>(2.0)) / vec2<f32>(800.0, 450.0) * dof;\r\n        acc = acc + sample_texture(iChannel0, uv + offset).xyz;\r\n    }\r\n    return acc / 25.0;\r\n}\r\n\r\n \r\n @fragment\r\nfn main_fragment(@location(0) TexCoord : vec2<f32>) -> @location(0) vec4<f32> {\r\n\r\n\r\n    let uv : vec2<f32> = TexCoord.xy / uniforms.resolution.xy;\r\n\r\n    var col: vec4<f32> = sample_texture(iChannel0,TexCoord); // DpthFld(iChannel0, TexCoord).xyzz;\r\n    col = mix(col, col.yzxw, smoothstep(0.35, 0.6, length(TexCoord - 0.5)));\r\n    return pow(max(col, vec4<f32>(0.0)), vec4<f32>(1. / 2.2));\r\n}\r\n\r\n  \r\n  `\n};\n\n\n//# sourceURL=webpack://demolishedwebgpu/./example/shaders/shared/customMainShader.js?");

/***/ }),

/***/ "./example/shaders/wglsl/raytracedRollingBallShader.js":
/*!*************************************************************!*\
  !*** ./example/shaders/wglsl/raytracedRollingBallShader.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.raytracedRollingBallShader = void 0;\nconst Material_1 = __webpack_require__(/*! ../../../src/engine/Material */ \"./src/engine/Material.js\");\nexports.raytracedRollingBallShader = {\n    vertex: Material_1.defaultWglslVertex,\n    fragment: /* wgsl */ `\r\n\r\n\tstruct VertexOutput {\r\n\t\t@builtin(position) pos: vec4<f32>,\r\n\t\t@location(0) uv: vec2<f32>\r\n\t  };    \r\n   \r\n\tstruct Uniforms {\r\n\t\tresolution: vec3<f32>,\r\n\t\ttime: f32,\r\n\t\tmouse: vec4<f32>,\r\n\t\tframe: f32\r\n\t };\r\n\r\n\r\n\t @group(0) @binding(0) var<uniform> uniforms: Uniforms;\r\n\t @group(0) @binding(1) var linearSampler: sampler;\r\n\t @group(0) @binding(2) var iChannel0: texture_2d<f32>; \r\n\r\n\r\n\r\n\tconst ballRad: f32 = 0.5;\r\n\r\n\tvar<private> sph4: vec4<f32> = vec4<f32>(0., ballRad - 1., 1., ballRad);\r\n\tvar<private> boxNrm: vec3<f32>;\r\n\tvar<private> seed: vec2<f32> = vec2<f32>(0.183, 0.257);\r\n\t\r\n\tfn floatBitsToInt(value: f32) -> i32 {\r\n\t\treturn i32(value);\r\n\t}\r\n\t\t\r\n\tfn floatBitsToUint(value: f32) -> u32 {\r\n\t\treturn u32(value);\r\n\t}\r\n\t\r\n\tfn sample_texture(tex:texture_2d<f32>,uv:vec2<f32>) -> vec4<f32>{\r\n\t\tlet result:vec4<f32> = textureSample(tex, linearSampler, -uv);\r\n\t\treturn result;\r\n\t}   \r\n\t\r\n\tfn rot2(a: f32) -> mat2x2<f32> {\r\n\t\tvar c: f32 = cos(a);\r\n\t\tvar s: f32 = sin(a);\r\n\t\treturn mat2x2<f32>(c, -s, s, c);\r\n\t} \r\n\t\r\n\tfn hash21(f: vec2<f32>) -> f32 {\r\n\t \tvar p: vec2<u32> = vec2<u32>(floatBitsToUint(f.x),floatBitsToUint(f.y));\r\n\t\tp = 1664525u * ((p >> vec2<u32>(1u)) ^ p.yx);  // Use vec2<u32>(1u) for the right shift\r\n\t\treturn f32(1103515245u * (p.x ^ (p.y >> 3u))) / f32(4294967300.);\r\n\t}\r\n\t\r\n\tfn hash31(f: vec3<f32>) -> f32 {\r\n\t\tvar p: vec3<u32> = vec3<u32>(\r\n\t\t\tu32(f.x * 1000000.0),\r\n\t\t\tu32(f.y * 1000000.0),\r\n\t\t\tu32(f.z * 1000000.0)\r\n\t\t);\r\n\t\tp = 1103515245u * ((vec3<u32>(p.x >> 2u, p.y >> 2u, p.z >> 2u)) ^ ((vec3<u32>(p.y >> 1u, p.z >> 1u, p.x >> 1u)) ^ vec3<u32>(p.z >> 1u, p.x >> 1u, p.y >> 1u)));\r\n\t\tvar h32: u32 = 1103515245u * (((p.x ^ p.y) >> 3u) ^ (p.z >> 6u));\r\n\t\tvar n: u32 = h32 ^ (h32 >> 16);\r\n\t\treturn f32(n & 2147483600u) / 2147483600.0;\r\n\t}\r\n\t\r\n\tfn hash22() -> vec2<f32> {\r\n\t\t// Update the seed using fract to ensure it stays within [0, 1].\r\n\t\tseed = fract(seed + vec2<f32>(0.7123, 0.6457));\r\n\t\t\r\n\t\t// Convert each component of the seed to unsigned integer separately.\r\n\t\tvar p: vec2<u32> = vec2<u32>(floatBitsToUint(seed.x), floatBitsToUint(seed.y));\r\n\t\t\r\n\t\t// Perform bitwise operations and multiplication.\r\n\t\tp = 1103515245u * ((p >> vec2<u32>(1u)) ^ p.yx);\r\n\t\t\r\n\t\t// Calculate h32 using bitwise operations.\r\n\t\tlet h32: u32 = 1103515245u * (p.x ^ (p.y >> 3u));\r\n\t\t\r\n\t\t// Calculate n using bitwise XOR.\r\n\t\tvar n: u32 = h32 ^ (h32 >> 16);\r\n\t\t\r\n\t\t// Construct rz using bitwise operations and multiplication.\r\n\t\tlet rz: vec2<u32> = vec2<u32>(n, n * 48271u);\r\n\t\t\r\n\t\t// Return a vec2<f32> by performing bitwise AND and division.\r\n\t\treturn vec2<f32>((rz >> vec2<u32>(1u)) & vec2<u32>(2147483600u)) / 2147483600.0;\r\n\t}\r\n\t\r\n\r\n\t\r\n\tfn sBox(p: vec2<f32>, b: vec2<f32>, r: f32) -> f32 {\r\n\t\tvar d: vec2<f32> = abs(p) - b + vec2<f32>(r);\r\n\t\treturn min(max(d.x, d.y), 0.0) + length(max(vec2<f32>(d.x, 0.0), vec2<f32>(d.y, 0.0))) - r;\r\n\t}\r\n\t\r\n\tfn cosDir(seed: f32, n: vec3<f32>) -> vec3<f32> {\r\n\t\tvar rnd: vec2<f32> = hash22();\r\n\t\tvar u: f32 = rnd.x;\r\n\t\tlet v: f32 = rnd.y;\r\n\t\tlet a: f32 = 6.2831855 * v;\r\n\t\tu = 2. * u - 1.;\r\n\t\treturn normalize(n + vec3<f32>(sqrt(1. - u * u) * vec2<f32>(cos(a), sin(a)), u));\r\n\t} \r\n\t\r\n\tfn sphereNorm(p: vec3<f32>, id: f32, sph: vec4<f32>) -> vec3<f32> {\r\n\t\treturn (p - sph.xyz) / sph.w;\r\n\t} \r\n\t\r\n\tfn boxIntersect(ro: vec3<f32>, rd: vec3<f32>, dim: vec3<f32>) -> vec4<f32> {\r\n\t\tlet maxT: f32 = 100000000.;\r\n\t\tvar minD: vec3<f32> = (ro + dim) / rd;\r\n\t\tvar maxD: vec3<f32> = (ro - dim) / rd;\r\n\t\tminD = -(minD - step(vec3<f32>(-0.000001), minD) * (minD + maxT));\r\n\t\tmaxD = -(maxD - step(vec3<f32>(-0.000001), maxD) * (maxD + maxT));\r\n\t\tminD = min(minD, maxD);\r\n\t\tvar res: vec4<f32> = vec4<f32>(maxT, 0., 0., 0.);\r\n\t\tif (minD.x < maxT) {\r\n\t\t\tvar pd: f32 = abs(ro.y + rd.y * minD.x) - dim.y;\r\n\t\t\tif (pd < 0.) { res = vec4<f32>(minD.x, -sign(rd.x), 0., 0.); }\r\n\t\t}\r\n\t\tif (minD.y < maxT) {\r\n\t\t\tvar pd: f32 = abs(ro.x + rd.x * minD.y) - dim.x;\r\n\t\t\tif (pd < 0.) { res = vec4<f32>(minD.y, 0., -sign(rd.y), 0.); }\r\n\t\t}\r\n\t\treturn res;\r\n\t} \r\n\t\r\n\tfn sphereIntersect(ro: vec3<f32>, rd: vec3<f32>, sph: vec4<f32>) -> vec2<f32> {\r\n\t\tlet oc: vec3<f32> = ro - sph.xyz;\r\n\t\tlet b: f32 = dot(oc, rd);\r\n\t\tif (b > 0.) {\treturn vec2<f32>(100000000., 0.);\r\n\t }\r\n\t\tvar c: f32 = dot(oc, oc) - sph.w * sph.w;\r\n\t\tlet h: f32 = b * b - c;\r\n\t\tif (h < 0.) {\treturn vec2<f32>(100000000., 0.);\r\n\t }\r\n\t\treturn vec2<f32>(-b - sqrt(h), 1.);\r\n\t} \r\n\t\r\n\t\r\n\tfn getNorm(p: vec3<f32>, id: f32) -> vec3<f32> {\r\n\t\tvar norm:vec3<f32> = boxNrm;\r\n\t\tif (id < 0.5){ \r\n\t\t\tnorm = sphereNorm(p, id, sph4);\r\n\t\t\t } \r\n\t\treturn norm;\r\n\t\t\t  \r\n\t} \r\n\t\r\n\tfn intersect(ro: vec3<f32>, rd: vec3<f32>) -> vec3<f32> {\r\n\t\r\n\t\tvar q: array<vec2<f32>, 2>;\r\n\t\r\n\t\tq[0] = sphereIntersect(ro, rd, sph4);\r\n\t\tlet bx: vec4<f32> = boxIntersect(ro - vec3<f32>(0., 1.5 - 1., -0.5 * 0.), rd, vec3<f32>(2., 1.5, 100000000.));\r\n\t\tq[1] = vec2<f32>(bx.x, 1.);\r\n\t\tboxNrm = bx.yzw;\r\n\t\t\r\n\t\tif (q[0].x < q[1].x) {\r\n\t\t\treturn vec3<f32>(q[0], 0.);\r\n\t\t} else {\r\n\t\t\treturn vec3<f32>(q[1], 1.);\r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tfn distField2(p: vec2<f32>, scl: f32, rndZ: f32, oID: f32) -> vec3<f32> {\r\n\t\tvar p_var = p;\r\n\t\tlet ew: f32 = 0.0125;\r\n\t\tvar pp: vec2<f32> = abs(fract(p_var) - 0.5);\r\n\t\tvar sq: f32 = abs(max(pp.x, pp.y) - 0.5) - ew * 2.;\r\n\t\tlet sc: vec2<f32> = vec2<f32>(1., 1.) / scl;\r\n\t\tlet ip: vec2<f32> = floor(p_var / sc);\r\n\t\tp_var = p_var - ((ip + 0.5) * sc);\r\n\t\tvar d: f32 = sBox(p_var, sc / 2. - ew, 0.1 * min(sc.x, sc.y) * 0.);\r\n\r\n\r\n\t\tlet hashResult:f32 = hash21(ip + rndZ * 0.123 + oID + 0.055);\r\n\r\n\t\tlet hsh:f32 = hash21(ip + rndZ * 0.401 + oID + 0.043) * 64.;\r\n\r\n\t\tif (hashResult < 0.65) {\r\n\t\t\tvar f: f32 = scl * 4.;\r\n\t\t\tvar n: f32 = floor(hsh) * 3.14159 / 4.;\r\n\t\t\tvar uv: vec2<f32> = rot2(n) * (p_var + vec2<f32>(f / 2., 0.));\r\n\t\t\tvar g: f32 = (abs(fract(uv.x * f + n * f * 0.) - 0.5) - 0.175) / f;\r\n\t\t\td = max(d, g);\r\n\t\t}\r\n\t\tif (oID == 0.) { d = max(d, -sq); }\r\n\t\treturn vec3<f32>(d, ip * sc);\r\n\t} \r\n\t\r\n\tfn distField(p: vec2<f32>, scl: f32, oID: f32) -> vec3<f32> {\r\n\t\tvar p_var = p;\r\n\t\tp_var = p_var * (scl);\r\n\t\tvar rnd: f32 = hash21(floor(p_var) + oID * 0.123);\r\n\t\tlet p2: vec2<f32> = p_var / (rnd + 0.1);\r\n\t\tlet pp: vec2<f32> = fract(p2) - 0.5;\r\n\t\tlet sq: f32 = (abs(max(abs(pp.x), abs(pp.y)) - 0.5) - 1. / 40.) / 2. * (rnd + 0.1);\r\n\t;\r\n\t\trnd = hash21(floor(p2) + oID * 0.123);\r\n\t\tlet n: f32 = floor(rnd * 64.) * 3.14159 / 4.;\r\n\t\tvar id: vec2<f32> = rnd + ceil(p2);\r\n\t\tvar f: f32 = 1. / hash21(floor(id) + oID * 0.123) / 3.14159;\r\n\t\tvar g: f32 = (abs(fract((rot2(n) * p_var).x * f) - 0.5) - 0.25) / f;\r\n\t\tg = max(g, -sq);\r\n\t\treturn vec3<f32>(g, id);\r\n\t} \r\n\t\r\n\tfn sBoxS(p: vec2<f32>, b: vec2<f32>, rf: f32) -> f32 {\r\n\t\tlet d: vec2<f32> = abs(p) - b + vec2<f32>(rf);\r\n\t\tlet inside: vec2<f32> = max(vec2<f32>(d.x, 0.0), vec2<f32>(d.y, 0.0));\r\n\t\treturn min(max(d.x, d.y), 0.0) + length(inside) - rf;\r\n\t}\r\n\r\n\t\r\n\tfn rot(ang: vec3<f32>) -> mat3x3<f32> {\r\n\t\tlet c: vec3<f32> = cos(ang);\r\n\t\tlet s: vec3<f32> = sin(ang);\r\n\t\treturn mat3x3<f32>(c.x * c.z - s.x * s.y * s.z, -s.x * c.y, -c.x * s.z - s.x * s.y * c.z, c.x * s.y * s.z + s.x * c.z, c.x * c.y, c.x * s.y * c.z - s.x * s.z, c.y * s.z, -s.y, c.y * c.z);\r\n\t} \r\n\t\r\n\tfn cubeMap(p: vec3<f32>) -> vec4<f32> {\r\n\t\tvar f: vec3<f32> = abs(p);\r\n\t\tf = step(f.zxy, f) * step(f.yzx, f);\r\n\t\t\r\n\t\tvar idF: vec3<i32>;\r\n\t\tif (p.x < 0.) {\r\n\t\t\tidF.x = -1;\r\n\t\t} else {\r\n\t\t\tidF.x = 1;\r\n\t\t}\r\n\t\tif (p.y < 0.) {\r\n\t\t\tidF.y = -1;\r\n\t\t} else {\r\n\t\t\tidF.y = 1;\r\n\t\t}\r\n\t\tif (p.z < 0.) {\r\n\t\t\tidF.z = -1;\r\n\t\t} else {\r\n\t\t\tidF.z = 1;\r\n\t\t}\r\n\t\t\r\n\t\tvar faceID: vec3<i32> = (idF + 1) / 2 + vec3<i32>(0, 2, 4);\r\n\t\t\r\n\t\tif (f.x > 0.5) {\r\n\t\t\treturn vec4<f32>(p.yz / p.x, f32(idF.x), f32(faceID.x));\r\n\t\t} else {\r\n\t\t\tif (f.y > 0.5) {\r\n\t\t\t\treturn vec4<f32>(p.xz / p.y, f32(idF.y), f32(faceID.y));\r\n\t\t\t} else {\r\n\t\t\t\treturn vec4<f32>(p.xy / p.z, f32(idF.z), f32(faceID.z));\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t\t\r\n\r\n\tfn mainImage(invocation_id:vec2<f32>) -> vec4<f32>{\r\n\r\n\t\tlet R: vec2<f32> = uniforms.resolution.xy;\r\n\t\tlet y_inverted_location = vec2<i32>(i32(invocation_id.x), i32(R.y) - i32(invocation_id.y));\r\n\t\tlet location = vec2<i32>(i32(y_inverted_location.x), i32(y_inverted_location.y));\r\n\t\t\r\n\t\tvar fragColor: vec4<f32>;\r\n\t\tvar fragCoord = vec2<f32>(f32(location.x), f32(location.y) );\r\n\t\r\n\t\tlet sf: f32 = 1. / uniforms.resolution.y;\r\n\t\tlet iRes: f32 = uniforms.resolution.y;\r\n\r\n\t\tlet seed0: vec2<f32> = fract(uniforms.time / vec2<f32>(111.13, 57.61)) * vec2<f32>(-0.143, 0.457);\r\n\r\n\t\tlet uv0: vec2<f32> = (fragCoord - uniforms.resolution.xy * 0.5) / iRes;\r\n\t\t\r\n\t\tlet FOV: f32 = 1.;\r\n\t\t\r\n\t\tlet ro: vec3<f32> = vec3<f32>(0., 0., uniforms.time * 2. + sin(uniforms.time) * 0.125);\r\n\t\t\r\n\t\tlet lk: vec3<f32> = ro + vec3<f32>(0., -0.01, 0.25);\r\n\t\tlet fwd: vec3<f32> = normalize(lk - ro);\r\n\t\tlet rgt: vec3<f32> = normalize(vec3<f32>(fwd.z, 0., -fwd.x));\r\n\t\tlet up: vec3<f32> = cross(fwd, rgt);\r\n\r\n\t\tvar mCam: mat3x3<f32> = mat3x3<f32>(rgt, up, fwd);\r\n\r\n\t\tmCam = mCam * (rot(vec3<f32>(0., 0.05, 0.)));\r\n\t\tmCam = mCam * (rot(vec3<f32>(0., 0., -sin(uniforms.time / 2.) * 0.25)));\r\n\r\n\t\tmCam = mCam * (rot(vec3<f32>(-cos(uniforms.time / 2.) * 0.25, 0., 0.)));\r\n\t\t\r\n\t\tif (uniforms.mouse.z > 0.) {\r\n\t\t\tlet ms: vec2<f32> = (uniforms.mouse.xy / uniforms.resolution.xy - 0.5) * vec2<f32>(3.14159 / 2.);\r\n\t\t\tmCam = mCam * (rot(vec3<f32>(0., ms.y / 2., -ms.x)));\r\n\t\t}\r\n\t\tsph4.x = sph4.x - (cos(uniforms.time / 2.) * 0.25);\r\n\t\tsph4.z = ro.z + 4.;\r\n\t\tvar aCol: vec3<f32> = vec3<f32>(0.);\r\n\t\tvar gT: f32 = 100000000.;\r\n\t\tvar avgT: f32 = 0.;\r\n\r\n\t\tlet frameC:i32 =i32(uniforms.frame);\r\n\t\r\n\t\tfor (var j: i32 = min(0, frameC); j < 12; j = j + 1) {\r\n\r\n\t\t\t//seed = uv0 + seed0 + vec2<f32>(j * 57., j * 27.) / 1321.;\r\n\r\n\t\t\tseed = uv0 + seed0 + vec2<f32>(f32(j) * 57., f32(j) * 27.) / 1321.;\r\n\r\n\t\t\tlet jit: vec2<f32> = hash22() * 2. - 1.;\r\n\t\t\tlet uv: vec2<f32> = uv0 - jit / uniforms.resolution.y;\r\n\t\t\tvar rd: vec3<f32> = mCam * normalize(vec3<f32>(uv, 1. / FOV));\r\n\t\t\tlet cam: vec3<f32> = ro;\r\n\t\t\tvar sp: vec3<f32> = ro;\r\n\t\t\tlet col: vec3<f32> = vec3<f32>(0.);\r\n\t\t\tvar emissive: vec3<f32> = vec3<f32>(0.);\r\n\t\t\tvar through: vec3<f32> = vec3<f32>(1.);\r\n\t\t\tvar sCol: vec3<f32> = vec3<f32>(0.);\r\n\t\t\tvar fogD: f32 = 100000000.;\r\n\t\r\n\t\t\tfor (var i: i32 = min(0, frameC); i < 3; i = i + 1) {\r\n\r\n\t\t\t\tlet scene: vec3<f32> = intersect(sp, rd);\r\n\t\t\t\tlet t: f32 = scene.x;\r\n\t\t\t\tlet retVal: f32 = scene.y;\r\n\t\t\t\tlet id: f32 = scene.z;\r\n\t\t\t\tif (i == 0) {\r\n\t\t\t\t\tfogD = t;\r\n\t\t\t\t\tavgT = avgT + (t / f32(12.));\r\n\t\t\t\t\tif (j == 0) { gT = fogD; }\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tsp = sp + (rd * t);\r\n\r\n\r\n\t\t\t\tif (t < 100000000.) {\r\n\t\t\t\t\r\n\t\t\t\t\tvar sn: vec3<f32> = getNorm(sp, id);\r\n\t\t\t\t\tvar oCol: vec3<f32> = vec3<f32>(0.);\r\n\t\t\t\t\tvar emissive: vec3<f32> = vec3<f32>(0.);\r\n\t\t\t\t\temissive = vec3<f32>(0.);\r\n\t\t\t\t\tvar rough: f32 = 0.;\r\n\r\n\t\t\t\t\tif (id < 0.5) {\r\n\t\t\t\t\t\tvar txP: vec3<f32> = sp - sph4.xyz;\r\n\t\t\t\t\t\tvar txPxy = txP.xy;\r\n\t\t\t\t\t\t\ttxPxy = txP.xy * (rot2(sph4.x / sph4.w / 2.));\r\n\t\t\t\t\t\t\ttxP.x = txPxy.x;\r\n\t\t\t\t\t\t\ttxP.y = txPxy.y;\r\n\t\t\t\t\t\t\t\t\t\t\tvar txPyz = txP.yz;\r\n\t\t\t\t\t\t\ttxPyz = txP.yz * (rot2(-sph4.z / sph4.w));\r\n\t\t\t\t\t\t\ttxP.y = txPyz.x;\r\n\t\t\t\t\t\t\ttxP.z = txPyz.y;\r\n\r\n\t\t\t\t\t\tlet q3: vec4<f32> = cubeMap(txP);\r\n\r\n\t\t\t\t\t\tlet faceID: f32 = q3.w;\r\n\t\t\t\t\t\tvar d3: vec3<f32> = distField2(q3.xy / 2. + 0.5, 6., q3.z, faceID);\r\n\r\n\t\t\t\t\t\td3.x = smoothstep(0., sf, d3.x);\r\n\t\t\t\t\t\tvar rnd2: f32 = hash21(d3.yz + q3.z * 0.051 + faceID + 0.024);\r\n\t\r\n\t\t\t\t\t\tlet sRnd: f32 = rnd2;\r\n\t\t\t\t\t\trnd2 = smoothstep(0.4, 0.45, sin(6.2831 * rnd2 + uniforms.time / 1.));\r\n\r\n\t\t\t\t\t\tvar wCol: vec3<f32> = 0.5 + 0.5 * cos(6.2831 * hash21(d3.yz + q3.z * 5.51 + faceID + 0.374) / 2. + vec3<f32>(0., 1., 2.) * 1.1 - 0.);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\toCol = mix(vec3<f32>(0.9, 0.95, 1.) * (hash21(d3.yz + q3.z * 2.035 + faceID + 0.144) * 0.5 + 0.5), vec3<f32>(0.1), d3.x);\r\n\t\t\t\t\t\twCol = wCol * vec3<f32>(4., 2., 1.);\r\n\t\t\t\t\t\temissive = mix(wCol * (rnd2 * 0.785 + 0.015) * 3. * vec3<f32>(1., 0.97, 0.92), vec3<f32>(0.005), d3.x);\r\n\t\t\t\t\t\trough = hash21(d3.yz + q3.z + 0.11);\r\n\t\t\t\t\t\trough = rough * rough * 0.3 + 0.025;\r\n\t\t\t\t\t\trough = rough * (hash31(sp + 0.51) * 0.5 + 0.75);\r\n\t\t\t\t\t\tif (hash21(d3.yz + faceID + 0.063) < 0.5) {\r\n\t\t\t\t\t\t\toCol = vec3<f32>(1.) * dot(oCol, vec3<f32>(0.299, 0.587, 0.114));\r\n\t\t\t\t\t\t\temissive = vec3<f32>(1.) * dot(emissive, vec3<f32>(0.299, 0.587, 0.114));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else { \r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t//let sgn: f32; if (abs(sn.z) > 0.5) { sgn = 1.; } else { sgn = -1.; };\r\n\r\n\t\t\t\t\t\tvar sgn: f32;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (abs(sn.z) > 0.5) { \r\n\t\t\t\t\t\t\tsgn = 1.;\r\n\t\t\t\t\t\t } else { \r\n\t\t\t\t\t\t\tsgn = -1.; \r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar wID: f32;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (sgn < 0.) {\r\n\t\t\t\t\t\t\tif (sp.y < 0.) \r\n\t\t\t\t\t\t\t\t{ wID =0.; } \r\n\t\t\t\t\t\t\telse { \r\n\t\t\t\t\t\t\t\twID =2.; \r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tif (sp.z < 0.) { \r\n\t\t\t\t\t\t\t\twID = 1.; } \r\n\t\t\t\t\t\t\t\telse { wID = 3.; }\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\r\n\r\n\r\n\t\t\t\t\t\t \r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar q: vec2<f32>;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (sgn > 0.5) { \r\n\t\t\t\t\t\t\tq = sp.xy; \r\n\t\t\t\t\t\t} else { \r\n\t\t\t\t\t\t\t if (abs(sn.x) > 0.5) { \r\n\t\t\t\t\t\t\t\tq = sp.yz; \r\n\t\t\t\t\t\t\t} else { \r\n\t\t\t\t\t\t\t\tq = sp.xz; \r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t };\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tvar strip: f32 = abs(((sp.z) % (4.)) - 2.) - 3. / 6.;\r\n\t\t\t\t\t\tvar yStrip: f32 = abs(sp.y - 0.5) - 1.5 + 1. / 6.;\r\n\r\n\r\n\t\t\t\t\t\tvar d3: vec3<f32>;\r\n\t\t\t\t\t\tif (strip < 0. && yStrip < 0.) {\t\t\t\t\t\r\n\t\t\t\t\t\t\t d3 = distField2(q, 6., wID, id);\r\n\t\t\t\t\t\t} else { \t\t\t\t\t\r\n\t\t\t\t\t\t\tif (abs(sn.y) > 0.5) {\r\n\t\t\t\t\t\t\t\t\td3 = distField(q, 4., wID);\r\n\t\t\t\t\t\t} \r\n\t\t\t\t\t\telse { \t\t\t\t\t\r\n\t\t\t\t\t\t\td3 = distField(q, 2., wID);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\td3.x = smoothstep(0., sf, d3.x);\r\n\r\n\t\t\t\t\t\tvar wCol: vec3<f32> = 0.5 + 0.5 * cos(6.2831 * hash21(d3.yz + wID * 0.054 + 0.274) / 2. + vec3<f32>(0., 1., 2.) * 1.1 - 1.5 * 1.);\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tlet wCol2: vec3<f32> = 0.5 + 0.5 * cos(6.2831 * hash21(d3.yz + wID * 0.054 + 0.273) / 2. + vec3<f32>(0., 1., 2.) * 1.1);\r\n\r\n\t\t\t\t\t\tif (strip > 0.) {\r\n\t\t\t\t\t\t\twCol = vec3<f32>(1.) * dot(wCol2, vec3<f32>(0.299, 0.587, 0.114));\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\twCol = wCol2 * vec3<f32>(4., 2., 1.);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\toCol = mix(vec3<f32>(0.9, 0.95, 1.) * (hash21(d3.yz + wID * 0.054 + 0.174) * 0.5 + 0.5), vec3<f32>(0.1), d3.x);\r\n\t\t\t\t\t\tvar rnd2: f32 = hash21(d3.yz + 0.067);\r\n\t\t\t\t\t\trnd2 = smoothstep(0.4, 0.47, sin(6.2831 * rnd2 + uniforms.time / 1.) * 0.5);\r\n\t\t\t\t\t\tif (abs(sn.y) < 0.5 && yStrip < 0.) { \r\n\t\t\t\t\t\t\temissive = mix(wCol * rnd2 * 4. * vec3<f32>(1., 0.97, 0.92), vec3<f32>(0.005), d3.x); \r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (abs(sn.x) > 0.5 && abs(yStrip - 0.015) - 0.015 < 0.) {\r\n\t\t\t\t\t\t\toCol = oCol * (0.);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trough = hash21(d3.yz + wID * 0.021 + 0.11);\r\n\t\t\t\t\t\trough = rough * rough * 0.3 + 0.025;\r\n\t\t\t\t\t\trough = rough * (hash31(sp + 0.41) * 0.5 + 0.75);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tsCol = sCol + (emissive * through);\r\n\t\t\t\t\tthrough = through * (oCol);\r\n\t\t\t\t\tlet refl: vec3<f32> = reflect(rd, sn);\r\n\t\t\t\t\tlet rrd: vec3<f32> = cosDir(0., sn);\r\n\t\t\t\t\trd = normalize(mix(refl, rrd, rough));\r\n\t\t\t\t\tif (dot(rd, sn) < 0.) { \r\n\t\t\t\t\t\trd = -rd;\r\n\t\t\t\t\t }\r\n\t\t\t\t\tsp = sp + (sn * 0.00001);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (aCol.x > 100000.) {\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\tsCol = mix(vec3<f32>(0.), sCol, 1. / (1. + fogD * fogD * 0.02));\r\n\t\t\taCol = aCol + (sCol);\r\n\t\t\tif (sCol.x > 100000.) {\t\t\r\n\t\t\t\tbreak;\r\n\t \t\t}\r\n\t\t}\r\n\t\r\n\t\taCol = aCol / (f32(12.));\r\n\t\t\r\n\t\tlet preCol: vec4<f32> = sample_texture(iChannel0, fragCoord);\r\n\r\n\t\tvar blend: f32; \r\n\t\t\r\n\t\tif (uniforms.frame < 2) \r\n\t\t\t{ \r\n\t\t\t\tblend = 1.; \r\n\t\t\t} \r\n\t\telse {\r\n\r\n\t\t\tblend = 1. / 2.; \r\n\t\t};\r\n\t\t\r\n\t\tblend = 1.;\r\n\t\tfragColor = mix(preCol, vec4<f32>(max(aCol, vec3<f32>(0.)), avgT), blend);\r\n\t\treturn fragColor;\r\n\t}\r\n\r\n\r\n\t@fragment\r\n\tfn main_fragment(vert: VertexOutput) -> @location(0) vec4<f32> {    \r\n\t\t\r\n\t\treturn mainImage(vert.pos.xy);\r\n\t\t\t\r\n \r\n\t}\r\n\r\n\t\r\n\r\n`\n};\n\n\n//# sourceURL=webpack://demolishedwebgpu/./example/shaders/wglsl/raytracedRollingBallShader.js?");

/***/ }),

/***/ "./src/engine/ComputePassBuilder.js":
/*!******************************************!*\
  !*** ./src/engine/ComputePassBuilder.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ComputePassBuilder = void 0;\nclass ComputePassBuilder {\n    constructor(device, canvas) {\n        this.canvas = canvas;\n        this.device = device;\n    }\n    getRenderPiplelineBindingGroupLayout(uniformBuffer, sampler) {\n        const bindingGroupEntrys = [];\n        bindingGroupEntrys.push({\n            binding: 0,\n            resource: {\n                buffer: uniformBuffer\n            }\n        });\n        const defaultSampler = this.device.createSampler({\n            addressModeU: 'repeat',\n            addressModeV: 'repeat',\n            magFilter: 'linear',\n            minFilter: 'nearest'\n        });\n        bindingGroupEntrys.push({\n            binding: 1,\n            resource: sampler || defaultSampler\n        });\n        return bindingGroupEntrys;\n    }\n    createRenderPipeline(material, geometry, textures) {\n        const bindGroupLayoutEntries = new Array();\n        bindGroupLayoutEntries.push({\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,\n            buffer: {\n                type: \"uniform\"\n            }\n        });\n        // const sampler = this.device.createSampler({\n        //     addressModeU: 'repeat',\n        //     addressModeV: 'repeat',\n        //     magFilter: 'linear',\n        //     minFilter: 'nearest'\n        // });\n        bindGroupLayoutEntries.push({\n            binding: 1,\n            visibility: GPUShaderStage.COMPUTE | GPUShaderStage.FRAGMENT,\n            sampler: {\n                type: \"filtering\"\n            }\n        });\n        if (textures.length > 0) {\n            for (let i = 0; i < textures.length; i++) { //  1-n texture bindings\n                if (textures[i].type === 0) {\n                    bindGroupLayoutEntries.push({\n                        binding: 2 + i,\n                        visibility: GPUShaderStage.FRAGMENT,\n                        texture: {\n                            sampleType: \"float\"\n                        }\n                    });\n                }\n                else {\n                    bindGroupLayoutEntries.push({\n                        binding: 2 + i,\n                        visibility: GPUShaderStage.FRAGMENT,\n                        externalTexture: {}\n                    });\n                }\n            }\n        }\n        const bindGroupLayout = this.device.createBindGroupLayout({\n            entries: bindGroupLayoutEntries\n        });\n        const pipeline = this.device.createRenderPipeline({\n            layout: this.device.createPipelineLayout({\n                bindGroupLayouts: [bindGroupLayout],\n            }),\n            vertex: {\n                module: material.vertexShaderModule,\n                entryPoint: \"main_vertex\",\n                buffers: [geometry.vertexBufferLayout(0)]\n            },\n            fragment: {\n                module: material.fragmentShaderModule,\n                entryPoint: \"main_fragment\",\n                targets: [\n                    {\n                        format: 'bgra8unorm'\n                    }\n                ]\n            }\n        });\n        return pipeline;\n    }\n    createComputePipeline(computeShader, textures) {\n        const bindGroupLayoutEntries = new Array();\n        bindGroupLayoutEntries.push({\n            binding: 0,\n            visibility: GPUShaderStage.COMPUTE,\n            storageTexture: {\n                access: \"write-only\",\n                format: \"bgra8unorm\",\n                viewDimension: \"2d\"\n            },\n        }, {\n            binding: 1, visibility: GPUShaderStage.COMPUTE,\n            buffer: {\n                type: \"uniform\"\n            }\n        });\n        if (textures.length > 0) {\n            for (let i = 0; i < textures.length; i++) { //  1-n texture bindings\n                if (textures[i].type === 0) {\n                    bindGroupLayoutEntries.push({\n                        binding: 3 + i,\n                        visibility: window.GPUShaderStage.COMPUTE,\n                        texture: {\n                            sampleType: \"float\"\n                        }\n                    });\n                }\n                else {\n                    bindGroupLayoutEntries.push({\n                        binding: 3 + i,\n                        visibility: window.GPUShaderStage.COMPUTE,\n                        externalTexture: {}\n                    });\n                }\n            }\n        }\n        const bindGroupLayout = this.device.createBindGroupLayout({\n            entries: bindGroupLayoutEntries\n        });\n        const pipeline = this.device.createComputePipeline({\n            layout: this.device.createPipelineLayout({\n                bindGroupLayouts: [bindGroupLayout],\n            }),\n            compute: {\n                module: computeShader,\n                entryPoint: 'main',\n            },\n        });\n        return pipeline;\n    }\n}\nexports.ComputePassBuilder = ComputePassBuilder;\n\n\n//# sourceURL=webpack://demolishedwebgpu/./src/engine/ComputePassBuilder.js?");

/***/ }),

/***/ "./src/engine/ComputeRenderer.js":
/*!***************************************!*\
  !*** ./src/engine/ComputeRenderer.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ComputeRenderer = void 0;\nconst Rectangle_1 = __webpack_require__(/*! ../../example/meshes/Rectangle */ \"./example/meshes/Rectangle.js\");\nconst IPass_1 = __webpack_require__(/*! ./IPass */ \"./src/engine/IPass.js\");\nconst ComputePassBuilder_1 = __webpack_require__(/*! ./ComputePassBuilder */ \"./src/engine/ComputePassBuilder.js\");\nconst Uniforms_1 = __webpack_require__(/*! ./Uniforms */ \"./src/engine/Uniforms.js\");\nconst Geometry_1 = __webpack_require__(/*! ./Geometry */ \"./src/engine/Geometry.js\");\nconst TextureLoader_1 = __webpack_require__(/*! ./TextureLoader */ \"./src/engine/TextureLoader.js\");\nclass ComputeRenderer {\n    //renderPassBuilder: RenderPassBuilder;\n    // computeBuffer: GPUTexture;\n    // computeBufferView: GPUTextureView;\n    constructor(canvas) {\n        this.canvas = canvas;\n        this.renderPassBacklog = new Map();\n        this.textures = new Array();\n    }\n    init() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const adapter = yield ((_a = navigator.gpu) === null || _a === void 0 ? void 0 : _a.requestAdapter());\n            const hasBGRA8unormStorage = adapter.features.has('bgra8unorm-storage');\n            const device = yield (adapter === null || adapter === void 0 ? void 0 : adapter.requestDevice({\n                requiredFeatures: hasBGRA8unormStorage\n                    ? ['bgra8unorm-storage']\n                    : [],\n            }));\n            if (!device) {\n                throw \"need a browser that supports WebGPU\";\n            }\n            const presentationFormat = hasBGRA8unormStorage\n                ? navigator.gpu.getPreferredCanvasFormat()\n                : 'rgba8unorm';\n            const context = this.canvas.getContext(\"webgpu\");\n            context.configure({\n                device,\n                format: presentationFormat,\n                usage: GPUTextureUsage.TEXTURE_BINDING |\n                    GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT,\n            });\n            this.renderPassBuilder = new ComputePassBuilder_1.ComputePassBuilder(device, this.canvas);\n            //    this.renderPassBuilder = new RenderPassBuilder(device,this.canvas);\n            this.device = device;\n            this.context = context;\n            this.geometry = new Geometry_1.Geometry(device, Rectangle_1.rectGeometry);\n            this.uniforms = new Uniforms_1.Uniforms(this.device, this.canvas);\n            this.canvas.addEventListener(\"mousemove\", (evt) => {\n                if (evt.buttons) {\n                    const rect = this.canvas.getBoundingClientRect();\n                    const x = evt.clientX - rect.left;\n                    const y = evt.clientY - rect.top;\n                    this.uniforms.setUniforms([x, y, evt.buttons, 0], 4);\n                    this.uniforms.updateUniformBuffer();\n                }\n            });\n        });\n    }\n    creatRenderPipeline(uniformBuffer, material) {\n        const bindingGroupEntrys = [];\n        const sampler = this.device.createSampler({\n            addressModeU: 'repeat',\n            addressModeV: 'repeat',\n            magFilter: 'linear',\n            minFilter: 'nearest'\n        });\n        bindingGroupEntrys.push({\n            binding: 0,\n            resource: sampler\n        }, {\n            binding: 1,\n            resource: {\n                buffer: uniformBuffer\n            }\n        });\n        const layout = new Array();\n        layout.push({\n            binding: 0,\n            visibility: GPUShaderStage.FRAGMENT,\n            sampler: {}\n        }, {\n            binding: 1,\n            visibility: GPUShaderStage.FRAGMENT,\n            buffer: {\n                type: \"uniform\"\n            }\n        });\n        const pipleline_group_layout = this.device.createBindGroupLayout({\n            entries: layout\n        });\n        const pipeline_layout = this.device.createPipelineLayout({\n            bindGroupLayouts: [pipleline_group_layout]\n        });\n        const pipelineDescriptor = {\n            vertex: {\n                module: material.vertexShaderModule,\n                entryPoint: material.shader.vertexEntryPoint || 'main_vertex',\n                buffers: [this.geometry.vertexBufferLayout(0)]\n            },\n            fragment: {\n                module: material.fragmentShaderModule,\n                entryPoint: material.shader.fragmentEntryPoint || 'main_fragment',\n                targets: [{\n                        format: 'bgra8unorm'\n                    }]\n            },\n            primitive: {\n                topology: 'triangle-list',\n            },\n            layout: pipeline_layout\n        };\n        return this.device.createRenderPipeline(pipelineDescriptor);\n    }\n    createMainRenderPipeline(uniformBuffer, material) {\n        const bindingGroupEntrys = [];\n        const sampler = this.device.createSampler({\n            addressModeU: 'repeat',\n            addressModeV: 'repeat',\n            magFilter: 'linear',\n            minFilter: 'nearest'\n        });\n        bindingGroupEntrys.push({\n            binding: 0,\n            resource: sampler\n        }, {\n            binding: 1,\n            resource: {\n                buffer: uniformBuffer\n            }\n        });\n        const layout = new Array();\n        layout.push({\n            binding: 0,\n            visibility: GPUShaderStage.FRAGMENT,\n            sampler: {}\n        }, {\n            binding: 1,\n            visibility: GPUShaderStage.FRAGMENT,\n            buffer: {\n                type: \"uniform\"\n            }\n        });\n        const computesPasses = Array.from(this.renderPassBacklog.values());\n        computesPasses.forEach((pass, i) => {\n            bindingGroupEntrys.push({\n                binding: 2 + i,\n                resource: pass.bufferView\n            });\n            layout.push({\n                binding: 2 + i,\n                visibility: GPUShaderStage.FRAGMENT,\n                texture: {}\n            });\n        });\n        const screen_bind_group_layout = this.device.createBindGroupLayout({\n            entries: layout\n        });\n        this.screen_bind_group = this.device.createBindGroup({\n            layout: screen_bind_group_layout,\n            entries: bindingGroupEntrys\n        });\n        const screen_pipeline_layout = this.device.createPipelineLayout({\n            bindGroupLayouts: [screen_bind_group_layout]\n        });\n        const pipelineDescriptor = {\n            vertex: {\n                module: material.vertexShaderModule,\n                entryPoint: material.shader.vertexEntryPoint || 'main_vertex',\n                buffers: [this.geometry.vertexBufferLayout(0)]\n            },\n            fragment: {\n                module: material.fragmentShaderModule,\n                entryPoint: material.shader.fragmentEntryPoint || 'main_fragment',\n                targets: [{\n                        format: 'bgra8unorm'\n                    }]\n            },\n            primitive: {\n                topology: 'triangle-list',\n            },\n            layout: screen_pipeline_layout\n        };\n        return this.device.createRenderPipeline(pipelineDescriptor);\n    }\n    createAssets() {\n        const buffer = this.device.createTexture({\n            size: {\n                width: this.canvas.width,\n                height: this.canvas.height,\n            },\n            format: \"bgra8unorm\",\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT\n        });\n        return { buffer, bufferView: buffer.createView() };\n    }\n    createBuffer(arr, usage, vertexSize) {\n        let bufferDescriptor = {\n            size: (arr.byteLength + vertexSize) & ~vertexSize,\n            usage,\n            mappedAtCreation: true\n        };\n        let buffer = this.device.createBuffer(bufferDescriptor);\n        const writeArray = arr instanceof Uint16Array\n            ? new Uint16Array(buffer.getMappedRange())\n            : new Float32Array(buffer.getMappedRange());\n        writeArray.set(arr);\n        buffer.unmap();\n        return buffer;\n    }\n    addMainPass(material) {\n        //let uniforms = new Uniforms(this.device, this.canvas);\n        this.renderPipleline = this.createMainRenderPipeline(this.uniforms.uniformBuffer, material);\n    }\n    addRenderPass(label, material, geometry, textures, samplers) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (samplers)\n                throw \"Samplers not yet implememted, using default binding 2\";\n            const uniforms = this.uniforms; //new Uniforms(this.device, this.canvas);\n            if (textures) {\n                for (let i = 0; i < textures.length; i++) {\n                    const texture = textures[i];\n                    if (texture.type == 0) {\n                        this.textures.push({ type: 0, data: yield TextureLoader_1.TextureLoader.createImageTexture(this.device, texture) });\n                    }\n                    else\n                        this.textures.push({ type: 1, data: yield TextureLoader_1.TextureLoader.createVideoTextue(this.device, texture) });\n                    console.log(`adding texture ${texture.key}`);\n                }\n            }\n            const renderPipeline = this.renderPassBuilder.createRenderPipeline(material, geometry, this.textures);\n            const assets = this.createAssets();\n            const bindingGroupEntrys = [];\n            const sampler = this.device.createSampler({\n                addressModeU: 'repeat',\n                addressModeV: 'repeat',\n                magFilter: 'linear',\n                minFilter: 'nearest'\n            });\n            bindingGroupEntrys.push({\n                binding: 0,\n                resource: {\n                    buffer: uniforms.uniformBuffer\n                }\n            }, {\n                binding: 1,\n                resource: sampler\n            });\n            // add the bindings for the textures and samplers.\n            const offset = bindingGroupEntrys.length;\n            this.textures.forEach((t, i) => {\n                let entry;\n                if (t.type === 0) {\n                    entry = {\n                        binding: i + offset,\n                        resource: t.data.createView()\n                    };\n                }\n                else {\n                    entry = {\n                        binding: i + 2,\n                        resource: this.device.importExternalTexture({ source: t.data }),\n                    };\n                }\n                bindingGroupEntrys.push(entry);\n            });\n            const bindGroup = this.device.createBindGroup({\n                layout: renderPipeline.getBindGroupLayout(0),\n                entries: bindingGroupEntrys,\n                label: `${label} renderpass`\n            });\n            const renderPass = new IPass_1.RenderPass(1, label, renderPipeline, uniforms, bindGroup, assets.buffer, assets.bufferView);\n            this.renderPassBacklog.set(label, renderPass);\n        });\n    }\n    addComputeRenderPass(label, computeShaderCode, textures, samplers) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (samplers)\n                throw \"Samplers not yet implememted, using default binding 2\";\n            const shaderModule = this.device.createShaderModule({ code: computeShaderCode });\n            const uniforms = this.uniforms; //new Uniforms(this.device, this.canvas);\n            for (let i = 0; i < textures.length; i++) {\n                const texture = textures[i];\n                if (texture.type == 0) {\n                    this.textures.push({ type: 0, data: yield TextureLoader_1.TextureLoader.createImageTexture(this.device, texture) });\n                }\n                else\n                    this.textures.push({ type: 1, data: yield TextureLoader_1.TextureLoader.createVideoTextue(this.device, texture) });\n            }\n            const computePipeline = this.renderPassBuilder.createComputePipeline(shaderModule, this.textures);\n            const assets = this.createAssets();\n            const bindingGroupEntrys = [];\n            const sampler = this.device.createSampler({\n                addressModeU: 'repeat',\n                addressModeV: 'repeat',\n                magFilter: 'linear',\n                minFilter: 'nearest'\n            });\n            bindingGroupEntrys.push({\n                binding: 0,\n                resource: assets.bufferView\n            }, {\n                binding: 1,\n                resource: {\n                    buffer: uniforms.uniformBuffer\n                }\n            });\n            const offset = bindingGroupEntrys.length;\n            this.textures.forEach((t, i) => {\n                let entry;\n                if (t.type === 0) {\n                    entry = {\n                        binding: i + offset,\n                        resource: t.data.createView()\n                    };\n                }\n                else {\n                    entry = {\n                        binding: i + 2,\n                        resource: this.device.importExternalTexture({ source: t.data }),\n                    };\n                }\n                bindingGroupEntrys.push(entry);\n            });\n            const bindGroup = this.device.createBindGroup({\n                layout: computePipeline.getBindGroupLayout(0),\n                entries: bindingGroupEntrys\n            });\n            const renderPass = new IPass_1.RenderPass(0, label, computePipeline, uniforms, bindGroup, assets.buffer, assets.bufferView);\n            console.log(\"adding a computeRender pass\", label);\n            this.renderPassBacklog.set(label, renderPass);\n        });\n    }\n    update(ts) {\n        const encoder = this.device.createCommandEncoder();\n        const arrRenderPasses = Array.from(this.renderPassBacklog.values());\n        // get the compute shaders from the back log\n        arrRenderPasses.filter((pre) => {\n            return pre.type == 0;\n        }).forEach(pass => {\n            pass.uniforms.setUniforms([this.frame], 8);\n            pass.uniforms.setUniforms([ts], 3);\n            pass.uniforms.updateUniformBuffer();\n            const computePass = encoder.beginComputePass();\n            computePass.setPipeline(pass.pipleline);\n            computePass.setBindGroup(0, pass.bindGroup);\n            computePass.dispatchWorkgroups(Math.floor((this.canvas.width + 7) / 8), Math.floor((this.canvas.height + 7) / 8), 1);\n            computePass.end();\n        });\n        arrRenderPasses.filter(pre => {\n            return pre.type == 1;\n        }).forEach(pass => {\n            const renderPassDescriptor = {\n                colorAttachments: [{\n                        loadOp: 'clear',\n                        storeOp: 'store',\n                        view: pass.bufferView,\n                        clearValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },\n                    }]\n            };\n            pass.uniforms.setUniforms([this.frame], 8);\n            pass.uniforms.setUniforms([ts], 3);\n            pass.uniforms.updateUniformBuffer();\n            const renderPass = encoder.beginRenderPass(renderPassDescriptor);\n            renderPass.setPipeline(pass.pipleline);\n            renderPass.setBindGroup(0, pass.bindGroup);\n            renderPass.setVertexBuffer(0, this.geometry.vertexBuffer);\n            renderPass.setIndexBuffer(this.geometry.indexBuffer, 'uint16');\n            renderPass.drawIndexed(this.geometry.numOfVerticles, 1);\n            renderPass.end();\n        });\n        const mainRenderer = encoder.beginRenderPass({\n            colorAttachments: [{\n                    view: this.context.getCurrentTexture().createView(),\n                    clearValue: { r: 0.0, g: 0, b: 0.0, a: 1 },\n                    loadOp: \"clear\",\n                    storeOp: \"store\"\n                }]\n        });\n        this.uniforms.setUniforms([this.frame], 8);\n        this.uniforms.setUniforms([ts], 3);\n        this.uniforms.updateUniformBuffer();\n        mainRenderer.setPipeline(this.renderPipleline);\n        mainRenderer.setVertexBuffer(0, this.geometry.vertexBuffer);\n        mainRenderer.setBindGroup(0, this.screen_bind_group);\n        mainRenderer.draw(6, 1, 0, 0);\n        mainRenderer.end();\n        this.device.queue.submit([encoder.finish()]);\n    }\n    start(t, maxFps = 200, onFrame) {\n        let startTime = null;\n        let frame = -1;\n        const renderLoop = (ts) => {\n            if (!startTime)\n                startTime = ts;\n            let segment = Math.floor((ts - startTime) / (1000 / maxFps));\n            if (segment > frame) {\n                frame = segment;\n                this.frame = segment;\n                this.frameCount = frame;\n                if (!this.isPaused)\n                    this.update(ts / 1000);\n                if (onFrame)\n                    onFrame(frame);\n            }\n            requestAnimationFrame(renderLoop);\n        };\n        renderLoop(t);\n    }\n    pause() {\n        this.isPaused = !this.isPaused;\n    }\n}\nexports.ComputeRenderer = ComputeRenderer;\n\n\n//# sourceURL=webpack://demolishedwebgpu/./src/engine/ComputeRenderer.js?");

/***/ }),

/***/ "./src/engine/Geometry.js":
/*!********************************!*\
  !*** ./src/engine/Geometry.js ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Geometry = exports.DefaultIndicies = exports.VERTEXType = void 0;\nvar VERTEXType;\n(function (VERTEXType) {\n    VERTEXType[VERTEXType[\"xyz\"] = 3] = \"xyz\";\n    VERTEXType[VERTEXType[\"xyzw\"] = 4] = \"xyzw\";\n    VERTEXType[VERTEXType[\"xyzrgba\"] = 7] = \"xyzrgba\";\n    VERTEXType[VERTEXType[\"xyzwrgba\"] = 8] = \"xyzwrgba\";\n})(VERTEXType || (exports.VERTEXType = VERTEXType = {}));\nexports.DefaultIndicies = new Uint16Array([0, 1, 2, 3, 4, 5]);\n// let createBuffer = (arr: Float32Array | Uint16Array, usage: number) => {\n//     let desc = {\n//         size: (arr.byteLength + 3) & ~3,\n//         usage,\n//         mappedAtCreation: true\n//     };\n//     let buffer = this.device.createBuffer(desc);\n//     const writeArray =\n//         arr instanceof Uint16Array\n//             ? new Uint16Array(buffer.getMappedRange())\n//             : new Float32Array(buffer.getMappedRange());\n//     writeArray.set(arr);\n//     buffer.unmap();\n//     return buffer;\n//};\nclass Geometry {\n    createBuffer(arr, usage, vertexSize) {\n        let desc = {\n            size: (arr.byteLength + vertexSize) & ~vertexSize,\n            usage,\n            mappedAtCreation: true\n        };\n        let buffer = this.device.createBuffer(desc);\n        const writeArray = arr instanceof Uint16Array\n            ? new Uint16Array(buffer.getMappedRange())\n            : new Float32Array(buffer.getMappedRange());\n        writeArray.set(arr);\n        buffer.unmap();\n        return buffer;\n    }\n    constructor(device, model) {\n        this.device = device;\n        this.model = model;\n        this.vertexBuffer = this.createBuffer(model.vertices, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST, model.verticesType);\n        this.indexBuffer = this.createBuffer(model.indicies, GPUBufferUsage.INDEX, 3);\n        this.numOfVerticles = model.vertices.length / model.verticesType;\n    }\n    vertexBufferLayout(shaderLocation) {\n        const vertexBufferLayout = {\n            attributes: [{\n                    shaderLocation: shaderLocation,\n                    offset: 0,\n                    format: 'float32x2'\n                }],\n            arrayStride: 4 * this.model.verticesType,\n            stepMode: 'vertex'\n        };\n        return vertexBufferLayout;\n    }\n}\nexports.Geometry = Geometry;\n\n\n//# sourceURL=webpack://demolishedwebgpu/./src/engine/Geometry.js?");

/***/ }),

/***/ "./src/engine/IPass.js":
/*!*****************************!*\
  !*** ./src/engine/IPass.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RenderPass = void 0;\nclass RenderPass {\n    constructor(type, label, pipleline, uniforms, bindGroup, buffer, bufferView) {\n        this.type = type;\n        this.label = label;\n        this.pipleline = pipleline;\n        this.uniforms = uniforms;\n        this.bindGroup = bindGroup;\n        this.buffer = buffer;\n        this.bufferView = bufferView;\n    }\n}\nexports.RenderPass = RenderPass;\n\n\n//# sourceURL=webpack://demolishedwebgpu/./src/engine/IPass.js?");

/***/ }),

/***/ "./src/engine/Material.js":
/*!********************************!*\
  !*** ./src/engine/Material.js ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Material = exports.defaultWglslVertex = void 0;\nexports.defaultWglslVertex = `  \r\n\r\nstruct VertexInput {\r\n  @location(0) pos: vec2<f32>,\r\n  @builtin(vertex_index) index : u32\r\n};  \r\n\r\nstruct VertexOutput {\r\n  @builtin(position) pos: vec4<f32>,\r\n  @location(0) uv: vec2<f32>,\r\n  @location(1) fragCoord: vec2<f32>\r\n};  \r\n\r\n\r\n@vertex\r\nfn main_vertex(input:VertexInput) -> VertexOutput {\r\n\r\n    var output: VertexOutput;\r\n\r\n    var pos: vec2<f32> = input.pos * 2.0 - 1.0;\r\n    output.pos = vec4<f32>(pos, 0.0, 1.0);\r\n    output.uv = pos;\r\n    output.fragCoord = vec2<f32>((pos.x + 1.0) / 2.0, (1.0 - pos.y) / 2.0); \r\n\r\n    return output;\r\n}`;\nclass Material {\n    constructor(device, shader) {\n        this.device = device;\n        this.shader = shader;\n        this.vertexShaderModule = this.device.createShaderModule({\n            code: shader.vertex\n        });\n        this.fragmentShaderModule = this.device.createShaderModule({\n            code: shader.fragment\n        });\n    }\n    static createMaterialShader(vertex, fragment, vertexEntryPoint, fragmentEntryPoint) {\n        const material = {\n            fragment: fragment,\n            fragmentEntryPoint: fragmentEntryPoint,\n            vertex: vertex,\n            vertexEntryPoint: vertexEntryPoint\n        };\n        return material;\n    }\n}\nexports.Material = Material;\n\n\n//# sourceURL=webpack://demolishedwebgpu/./src/engine/Material.js?");

/***/ }),

/***/ "./src/engine/TextureLoader.js":
/*!*************************************!*\
  !*** ./src/engine/TextureLoader.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TextureLoader = void 0;\nclass TextureLoader {\n    constructor() {\n    }\n    /**\n     * Load and create an GPUTexture from an Image\n     *\n     * @static\n     * @param {GPUDevice} device\n     * @param {string} texture\n     * @return {*}  {Promise<GPUTexture>}\n     * @memberof TextureLoader\n     */\n    static createImageTexture(device, texture) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const image = new Image();\n            image.src = texture.source;\n            yield image.decode();\n            const imageBitmap = yield createImageBitmap(image);\n            const textureSize = { width: image.width, height: image.height };\n            const gpuTexture = device.createTexture({\n                label: texture.key,\n                size: textureSize,\n                dimension: '2d',\n                format: 'rgba8unorm',\n                usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING\n            });\n            device.queue.copyExternalImageToTexture({\n                source: imageBitmap\n            }, {\n                texture: gpuTexture,\n                mipLevel: 0\n            }, textureSize);\n            return gpuTexture;\n        });\n    }\n    static createVideoTextue(device, texture) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const video = document.createElement(\"video\");\n            video.loop = true;\n            video.autoplay = true;\n            video.muted = true;\n            if (texture.source instanceof MediaStream) {\n                video.srcObject = texture.source;\n            }\n            else\n                video.src = texture.source;\n            yield video.play();\n            return video;\n        });\n    }\n}\nexports.TextureLoader = TextureLoader;\n\n\n//# sourceURL=webpack://demolishedwebgpu/./src/engine/TextureLoader.js?");

/***/ }),

/***/ "./src/engine/Uniforms.js":
/*!********************************!*\
  !*** ./src/engine/Uniforms.js ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Uniforms = void 0;\nclass Uniforms {\n    static initialize(w, h) {\n        return new Float32Array([w, h, 0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    constructor(device, canvas) {\n        this.device = device;\n        this.uniformBuffer = this.device.createBuffer({\n            size: 60,\n            usage: window.GPUBufferUsage.UNIFORM | window.GPUBufferUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,\n        });\n        this.uniformBufferArray = new Float32Array([canvas.width, canvas.height, 0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    setUniforms(values, offset) {\n        this.uniformBufferArray.set(values, offset); // time \n    }\n    updateUniformBuffer() {\n        this.device.queue.writeBuffer(this.uniformBuffer, 0, this.uniformBufferArray.buffer, this.uniformBufferArray.byteOffset, this.uniformBufferArray.byteLength);\n    }\n}\nexports.Uniforms = Uniforms;\n\n\n//# sourceURL=webpack://demolishedwebgpu/./src/engine/Uniforms.js?");

/***/ }),

/***/ "./src/interface/ITexture.js":
/*!***********************************!*\
  !*** ./src/interface/ITexture.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TextureType = void 0;\nvar TextureType;\n(function (TextureType) {\n    TextureType[TextureType[\"IMAGE\"] = 0] = \"IMAGE\";\n    TextureType[TextureType[\"VIDEO\"] = 1] = \"VIDEO\";\n    TextureType[TextureType[\"CANVAS\"] = 2] = \"CANVAS\";\n    TextureType[TextureType[\"MEDIASTREAM\"] = 3] = \"MEDIASTREAM\";\n})(TextureType || (exports.TextureType = TextureType = {}));\n\n\n//# sourceURL=webpack://demolishedwebgpu/./src/interface/ITexture.js?");

/***/ }),

/***/ "./node_modules/yy-fps/dist/fps.es.js":
/*!********************************************!*\
  !*** ./node_modules/yy-fps/dist/fps.es.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FPS: () => (/* binding */ FPS),\n/* harmony export */   defaultFPSOptions: () => (/* binding */ defaultFPSOptions)\n/* harmony export */ });\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\n\nvar defaultFPSOptions = {\n    meter: true,\n    side: 'bottom-right',\n    FPS: 60,\n    tolerance: 1,\n    meterWidth: 100,\n    meterHeight: 25,\n    meterLineHeight: 4,\n    styles: {\n        'background': 'rgba(0, 0, 0, 0.5)',\n        'color': 'white',\n    },\n    stylesFPS: {\n        'padding': '0.1em 0.5em',\n    },\n    text: ' FPS',\n    colorGreen: '#00ff00',\n    colorOrange: '#ffa500',\n    colorRed: '#ff0000',\n    zIndex: 1000,\n};\nvar FPS = /** @class */ (function () {\n    /**\n     * @param [options]\n     * @param [options.meter=true] - include a meter with the FPS\n     * @param [options.side=bottom-right] - include any combination of left/right and top/bottom\n     * @param [options.FPS=60] - desired FPS\n     * @param [options.tolerance=1] - minimum tolerance for fluctuations in FPS number\n     * @param [options.meterWidth=100] - width of meter div\n     * @param [options.meterHeight=25] - height of meter div\n     * @param [options.meterLineHeight=4] - height of meter line\n     * @param [options.styles] - CSS styles to apply to the div (in javascript format)\n     * @param [options.stylesFPS] - CSS styles to apply to the FPS text (in javascript format)\n     * @param [options.stylesMeter] - CSS styles to apply to the FPS meter (in javascript format)\n     * @param [options.text=\" FPS\"] - change the text to the right of the FPS\n     * @param [options.colorGreen=#ffa500] green (good) color on meter\n     * @param [options.colorRed = #ff0000] red (bad) color on meter\n     * @param [options.zIndex = 1000] zIndex to assign to div\n     */\n    function FPS(options) {\n        if (options === void 0) { options = {}; }\n        this.lastTime = 0;\n        this.frameNumber = 0;\n        this.lastFPS = 0;\n        this.options = __assign(__assign({}, defaultFPSOptions), options);\n        this.div = document.createElement('div');\n        this.findParent(this.options.side || 'bottom-right').appendChild(this.div);\n        this.style(this.div, this.options.styles);\n        this.createDivFPS();\n        if (this.options.meter) {\n            this.createDivMeter();\n        }\n    }\n    Object.defineProperty(FPS.prototype, \"fps\", {\n        /** desired FPS */\n        get: function () {\n            return this.options.FPS;\n        },\n        set: function (value) {\n            this.options.FPS = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /** remove meter from DOM */\n    FPS.prototype.remove = function () {\n        this.div.remove();\n    };\n    Object.defineProperty(FPS.prototype, \"meter\", {\n        /** meter (the FPS graph) is on or off */\n        get: function () {\n            return this.options.meter;\n        },\n        set: function (value) {\n            if (value) {\n                this.createDivMeter();\n            }\n            else if (this.meterCanvas) {\n                this.meterCanvas.style.display = 'none';\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    FPS.prototype.style = function (div, style) {\n        for (var entry in style) {\n            div.style[entry] = style[entry];\n        }\n    };\n    FPS.prototype.createDivFPS = function () {\n        var divFPS = document.createElement('div');\n        this.style(divFPS, this.options.stylesFPS);\n        this.div.appendChild(divFPS);\n        this.fpsSpan = document.createElement('span');\n        divFPS.appendChild(this.fpsSpan);\n        var span = document.createElement('span');\n        divFPS.appendChild(span);\n        span.innerText = this.options.text;\n    };\n    FPS.prototype.createDivMeter = function () {\n        if (!this.meterCanvas) {\n            this.meterCanvas = document.createElement('canvas');\n            this.div.appendChild(this.meterCanvas);\n            this.meterCanvas.width = this.options.meterWidth;\n            this.meterCanvas.height = this.options.meterHeight;\n            this.meterCanvas.style.width = this.options.meterWidth + 'px';\n            this.meterCanvas.style.height = this.options.meterHeight + 'px';\n            this.style(this.meterCanvas, this.options.stylesMeter);\n            this.meterContext = this.meterCanvas.getContext('2d', { willReadFrequently: true });\n        }\n        else {\n            this.meterCanvas.style.display = 'block';\n        }\n    };\n    /** call this at the end of the frame to calculate FPS */\n    FPS.prototype.frame = function () {\n        this.frameNumber++;\n        var currentTime = performance.now() - this.lastTime;\n        // skip large differences to remove garbage\n        if (currentTime > 500) {\n            if (this.lastTime !== 0) {\n                this.lastFPS = Math.floor(this.frameNumber / (currentTime / 1000));\n                if (this.lastFPS > this.options.FPS ||\n                    (this.lastFPS >= this.options.FPS - this.options.tolerance &&\n                        this.lastFPS <= this.options.FPS + this.options.tolerance)) {\n                    this.lastFPS = this.options.FPS;\n                }\n            }\n            this.lastTime = performance.now();\n            this.frameNumber = 0;\n        }\n        this.fpsSpan.innerText = this.lastFPS === 0 ? '--' : this.lastFPS + '';\n        if (this.options.meter && this.lastFPS !== 0) {\n            this.meterUpdate(this.lastFPS / this.options.FPS);\n        }\n    };\n    /**\n     * From https://github.com/bgrins/TinyColor#readme\n     * Mix two RGP colors\n     * @param color1 - first color\n     * @param color2 - second color\n     * @param percent - percent to mix\n     */\n    FPS.prototype.mix = function (color1, color2, percent) {\n        var rgb = function (color) {\n            return {\n                r: parseInt(color.substr(1, 2), 16),\n                g: parseInt(color.substr(3, 2), 16),\n                b: parseInt(color.substr(5, 2), 16),\n            };\n        };\n        var digit2 = function (n) {\n            n = Math.floor(n);\n            if (n.toString().length === 1) {\n                return '0' + n.toString(16);\n            }\n            else {\n                return n.toString(16);\n            }\n        };\n        var rgb1 = rgb(color1);\n        var rgb2 = rgb(color2);\n        var r = digit2(rgb1.r * percent + rgb2.r * (1 - percent));\n        var g = digit2(rgb1.g * percent + rgb2.g * (1 - percent));\n        var b = digit2(rgb1.b * percent + rgb2.b * (1 - percent));\n        return \"#\".concat(r).concat(g).concat(b);\n    };\n    FPS.prototype.meterUpdate = function (percent) {\n        var data = this.meterContext.getImageData(0, 0, this.meterCanvas.width, this.meterCanvas.height);\n        this.meterContext.putImageData(data, -1, 0);\n        this.meterContext.clearRect(this.meterCanvas.width - 1, 0, 1, this.meterCanvas.height);\n        if (percent <= 0.5) {\n            this.meterContext.fillStyle = this.mix(this.options.colorRed, this.options.colorOrange, 1 - percent * 2);\n        }\n        else {\n            this.meterContext.fillStyle = this.mix(this.options.colorGreen, this.options.colorOrange, (percent - 0.5) * 2);\n        }\n        var height = (this.meterCanvas.height - this.options.meterLineHeight) * (1 - percent);\n        this.meterContext.fillRect(this.meterCanvas.width - 1, height, 1, this.options.meterLineHeight);\n    };\n    /**\n     * find the parent div for one of the corners\n     * @param side side to place the panel (combination of right/left and bottom/top)\n     * @return {HTMLElement}\n     */\n    FPS.prototype.findParent = function (side) {\n        var styles = [];\n        var name = 'yy-counter-';\n        if (side.indexOf('left') !== -1) {\n            name += 'left-';\n            styles['left'] = 0;\n        }\n        else {\n            name += 'right-';\n            styles['right'] = 0;\n        }\n        if (side.indexOf('top') !== -1) {\n            name += 'top';\n            styles['top'] = 0;\n        }\n        else {\n            name += 'bottom';\n            styles['bottom'] = 0;\n        }\n        var test = document.getElementById(name);\n        if (test) {\n            return test;\n        }\n        var container = document.createElement('div');\n        container.id = name;\n        container.style.overflow = 'hidden';\n        container.style.position = 'fixed';\n        container.style.zIndex = this.options.zIndex.toString();\n        container.style.pointerEvents = 'none';\n        container.style.userSelect = 'none';\n        for (var style in styles) {\n            container.style[style] = styles[style];\n        }\n        document.body.appendChild(container);\n        return container;\n    };\n    return FPS;\n}());\n\n\n//# sourceMappingURL=fps.es.js.map\n\n\n//# sourceURL=webpack://demolishedwebgpu/./node_modules/yy-fps/dist/fps.es.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./example/Example.js");
/******/ 	
/******/ })()
;